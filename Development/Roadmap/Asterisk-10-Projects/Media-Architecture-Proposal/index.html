<!doctype html><html lang=en class=no-js> <head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link href=https://docs.asterisk.org/Development/Roadmap/Asterisk-10-Projects/Media-Architecture-Proposal/ rel=canonical><link href=../ rel=prev><link href=../Media-Overhaul/ rel=next><link rel=icon href=../../../../favicon.ico><meta name=generator content="mkdocs-1.6.1, mkdocs-material-9.6.19"><title>Media Architecture Proposal - Asterisk Documentation</title><link rel=stylesheet href=../../../../assets/stylesheets/main.7e37652d.min.css><link rel=stylesheet href=../../../../assets/stylesheets/palette.06af60db.min.css><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback"><style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style><link rel=stylesheet href=../../../../material-override.css><script>__md_scope=new URL("../../../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script><script id=__analytics>function __md_analytics(){function e(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],e("js",new Date),e("config","G-2ZKMCW9DZ9"),document.addEventListener("DOMContentLoaded",(function(){document.forms.search&&document.forms.search.query.addEventListener("blur",(function(){this.value&&e("event","search",{search_term:this.value})}));document$.subscribe((function(){var t=document.forms.feedback;if(void 0!==t)for(var a of t.querySelectorAll("[type=submit]"))a.addEventListener("click",(function(a){a.preventDefault();var n=document.location.pathname,d=this.getAttribute("data-md-value");e("event","feedback",{page:n,data:d}),t.firstElementChild.disabled=!0;var r=t.querySelector(".md-feedback__note [data-md-value='"+d+"']");r&&(r.hidden=!1)})),t.hidden=!1})),location$.subscribe((function(t){e("config","G-2ZKMCW9DZ9",{page_path:t.pathname})}))}));var t=document.createElement("script");t.async=!0,t.src="https://www.googletagmanager.com/gtag/js?id=G-2ZKMCW9DZ9",document.getElementById("__analytics").insertAdjacentElement("afterEnd",t)}</script><script>"undefined"!=typeof __md_analytics&&__md_analytics()</script></head> <body dir=ltr data-md-color-scheme=default data-md-color-primary=indigo data-md-color-accent=indigo> <input class=md-toggle data-md-toggle=drawer type=checkbox id=__drawer autocomplete=off> <input class=md-toggle data-md-toggle=search type=checkbox id=__search autocomplete=off> <label class=md-overlay for=__drawer></label> <div data-md-component=skip> <a href=#introduction class=md-skip> Skip to content </a> </div> <div data-md-component=announce> </div> <header class="md-header md-header--shadow" data-md-component=header> <nav class="md-header__inner md-grid" aria-label=Header> <a href=../../../.. title="Asterisk Documentation" class="md-header__button md-logo" aria-label="Asterisk Documentation" data-md-component=logo> <img src=../../../../favicon.ico alt=logo> </a> <label class="md-header__button md-icon" for=__drawer> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg> </label> <div class=md-header__title data-md-component=header-title> <div class=md-header__ellipsis> <div class=md-header__topic> <span class=md-ellipsis> Asterisk Documentation </span> </div> <div class=md-header__topic data-md-component=header-topic> <span class=md-ellipsis> Media Architecture Proposal </span> </div> </div> </div> <form class=md-header__option data-md-component=palette> <input class=md-option data-md-color-media="(prefers-color-scheme: light)" data-md-color-scheme=default data-md-color-primary=indigo data-md-color-accent=indigo aria-label="Switch to dark mode" type=radio name=__palette id=__palette_0> <label class="md-header__button md-icon" title="Switch to dark mode" for=__palette_1 hidden> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M12 8a4 4 0 0 0-4 4 4 4 0 0 0 4 4 4 4 0 0 0 4-4 4 4 0 0 0-4-4m0 10a6 6 0 0 1-6-6 6 6 0 0 1 6-6 6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12z"/></svg> </label> <input class=md-option data-md-color-media="(prefers-color-scheme: dark)" data-md-color-scheme=slate data-md-color-primary=indigo data-md-color-accent=indigo aria-label="Switch to light mode" type=radio name=__palette id=__palette_1> <label class="md-header__button md-icon" title="Switch to light mode" for=__palette_0 hidden> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M12 18c-.89 0-1.74-.2-2.5-.55C11.56 16.5 13 14.42 13 12s-1.44-4.5-3.5-5.45C10.26 6.2 11.11 6 12 6a6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12z"/></svg> </label> </form> <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script> <label class="md-header__button md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg> </label> <div class=md-search data-md-component=search role=dialog> <label class=md-search__overlay for=__search></label> <div class=md-search__inner role=search> <form class=md-search__form name=search> <input type=text class=md-search__input name=query aria-label=Search placeholder=Search autocapitalize=off autocorrect=off autocomplete=off spellcheck=false data-md-component=search-query required> <label class="md-search__icon md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg> </label> <nav class=md-search__options aria-label=Search> <a href=javascript:void(0) class="md-search__icon md-icon" title=Share aria-label=Share data-clipboard data-clipboard-text data-md-component=search-share tabindex=-1> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9a3 3 0 0 0-3 3 3 3 0 0 0 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.15c-.05.21-.08.43-.08.66 0 1.61 1.31 2.91 2.92 2.91s2.92-1.3 2.92-2.91A2.92 2.92 0 0 0 18 16.08"/></svg> </a> <button type=reset class="md-search__icon md-icon" title=Clear aria-label=Clear tabindex=-1> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg> </button> </nav> <div class=md-search__suggest data-md-component=search-suggest></div> </form> <div class=md-search__output> <div class=md-search__scrollwrap tabindex=0 data-md-scrollfix> <div class=md-search-result data-md-component=search-result> <div class=md-search-result__meta> Initializing search </div> <ol class=md-search-result__list role=presentation></ol> </div> </div> </div> </div> </div> <div class=md-header__source> <table border=0 style="width: max-content;padding:0px;margin:0px"><tr><td> <a href=https://github.com/asterisk/asterisk title="Go to repository" class=md-source data-md-component=source> <div class="md-source__icon md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 512 512"><!-- Font Awesome Free 7.0.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path fill=currentColor d="M173.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6m-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3m44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9M252.8 8C114.1 8 8 113.3 8 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C436.2 457.8 504 362.9 504 252 504 113.3 391.5 8 252.8 8M105.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1m-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7m32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1m-11.4-14.7c-1.6 1-1.6 3.6 0 5.9s4.3 3.3 5.6 2.3c1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2"/></svg> </div> <div class=md-source__repository> Asterisk </div> </a> </td> <td style=font-size:.65rem;line-height:1.2;vertical-align:middle;> <a href=/About-the-Project/Asterisk-Versions>Asterisk Versions</a><br> <a target=_blank href=https://github.com/asterisk/documentation/issues>Report Documentation Issues</a><br> <a target=_blank href=https://github.com/asterisk/documentation>Contribute to the Documentation</a> </td></tr> </table> </div> </nav> </header> <div class=md-container data-md-component=container> <main class=md-main data-md-component=main> <div class="md-main__inner md-grid"> <div class="md-sidebar md-sidebar--primary" data-md-component=sidebar data-md-type=navigation> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--primary" aria-label=Navigation data-md-level=0> <label class=md-nav__title for=__drawer> <a href=../../../.. title="Asterisk Documentation" class="md-nav__button md-logo" aria-label="Asterisk Documentation" data-md-component=logo> <img src=../../../../favicon.ico alt=logo> </a> Asterisk Documentation </label> <div class=md-nav__source> <table border=0 style="width: max-content;padding:0px;margin:0px"><tr><td> <a href=https://github.com/asterisk/asterisk title="Go to repository" class=md-source data-md-component=source> <div class="md-source__icon md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 512 512"><!-- Font Awesome Free 7.0.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path fill=currentColor d="M173.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6m-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3m44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9M252.8 8C114.1 8 8 113.3 8 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C436.2 457.8 504 362.9 504 252 504 113.3 391.5 8 252.8 8M105.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1m-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7m32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1m-11.4-14.7c-1.6 1-1.6 3.6 0 5.9s4.3 3.3 5.6 2.3c1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2"/></svg> </div> <div class=md-source__repository> Asterisk </div> </a> </td> <td style=font-size:.65rem;line-height:1.2;vertical-align:middle;> <a href=/About-the-Project/Asterisk-Versions>Asterisk Versions</a><br> <a target=_blank href=https://github.com/asterisk/documentation/issues>Report Documentation Issues</a><br> <a target=_blank href=https://github.com/asterisk/documentation>Contribute to the Documentation</a> </td></tr> </table> </div> <ul class=md-nav__list data-md-scrollfix> <li class="md-nav__item md-nav__item--pruned md-nav__item--nested"> <a href=../../../../About-the-Project/ class=md-nav__link> <span class=md-ellipsis> About the Project </span> <span class="md-nav__icon md-icon"></span> </a> </li> <li class="md-nav__item md-nav__item--pruned md-nav__item--nested"> <a href=../../../../Asterisk-Community/ class=md-nav__link> <span class=md-ellipsis> Asterisk Community </span> <span class="md-nav__icon md-icon"></span> </a> </li> <li class="md-nav__item md-nav__item--pruned md-nav__item--nested"> <a href=../../../../Fundamentals/ class=md-nav__link> <span class=md-ellipsis> Fundamentals </span> <span class="md-nav__icon md-icon"></span> </a> </li> <li class="md-nav__item md-nav__item--pruned md-nav__item--nested"> <a href=../../../../Getting-Started/Beginning-Asterisk/ class=md-nav__link> <span class=md-ellipsis> Getting Started </span> <span class="md-nav__icon md-icon"></span> </a> </li> <li class="md-nav__item md-nav__item--pruned md-nav__item--nested"> <a href=../../../../Configuration/ class=md-nav__link> <span class=md-ellipsis> Configuration </span> <span class="md-nav__icon md-icon"></span> </a> </li> <li class="md-nav__item md-nav__item--pruned md-nav__item--nested"> <a href=../../../../Deployment/ class=md-nav__link> <span class=md-ellipsis> Deployment </span> <span class="md-nav__icon md-icon"></span> </a> </li> <li class="md-nav__item md-nav__item--pruned md-nav__item--nested"> <a href=../../../../Operation/ class=md-nav__link> <span class=md-ellipsis> Operation </span> <span class="md-nav__icon md-icon"></span> </a> </li> <li class="md-nav__item md-nav__item--active md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_8 checked> <div class="md-nav__link md-nav__container"> <a href=../../../ class="md-nav__link "> <span class=md-ellipsis> Development </span> </a> <label class="md-nav__link " for=__nav_8 id=__nav_8_label tabindex=0> <span class="md-nav__icon md-icon"></span> </label> </div> <nav class=md-nav data-md-level=1 aria-labelledby=__nav_8_label aria-expanded=true> <label class=md-nav__title for=__nav_8> <span class="md-nav__icon md-icon"></span> Development </label> <ul class=md-nav__list data-md-scrollfix> <li class="md-nav__item md-nav__item--pruned md-nav__item--nested"> <a href=../../../Policies-and-Procedures/ class=md-nav__link> <span class=md-ellipsis> Policies and Procedures </span> <span class="md-nav__icon md-icon"></span> </a> </li> <li class="md-nav__item md-nav__item--pruned md-nav__item--nested"> <a href=../../../Debugging/ class=md-nav__link> <span class=md-ellipsis> Debugging </span> <span class="md-nav__icon md-icon"></span> </a> </li> <li class="md-nav__item md-nav__item--pruned md-nav__item--nested"> <a href=../../../Reference-Information/ class=md-nav__link> <span class=md-ellipsis> Reference Information </span> <span class="md-nav__icon md-icon"></span> </a> </li> <li class="md-nav__item md-nav__item--active md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_8_5 checked> <div class="md-nav__link md-nav__container"> <a href=../../ class="md-nav__link "> <span class=md-ellipsis> Roadmap </span> </a> <label class="md-nav__link " for=__nav_8_5 id=__nav_8_5_label tabindex=0> <span class="md-nav__icon md-icon"></span> </label> </div> <nav class=md-nav data-md-level=2 aria-labelledby=__nav_8_5_label aria-expanded=true> <label class=md-nav__title for=__nav_8_5> <span class="md-nav__icon md-icon"></span> Roadmap </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../AstriCon-2012-Presentations/ class=md-nav__link> <span class=md-ellipsis> AstriCon 2012 Presentations </span> </a> </li> <li class=md-nav__item> <a href=../../AstriDevCon-2010/ class=md-nav__link> <span class=md-ellipsis> AstriDevCon 2010 </span> </a> </li> <li class=md-nav__item> <a href=../../AstriDevCon-2011/ class=md-nav__link> <span class=md-ellipsis> AstriDevCon 2011 </span> </a> </li> <li class=md-nav__item> <a href=../../AstriDevCon-2012/ class=md-nav__link> <span class=md-ellipsis> AstriDevCon 2012 </span> </a> </li> <li class=md-nav__item> <a href=../../AstriDevCon-2013/ class=md-nav__link> <span class=md-ellipsis> AstriDevCon 2013 </span> </a> </li> <li class=md-nav__item> <a href=../../AstriDevCon-2014/ class=md-nav__link> <span class=md-ellipsis> AstriDevCon 2014 </span> </a> </li> <li class=md-nav__item> <a href=../../AstriDevCon-2015/ class=md-nav__link> <span class=md-ellipsis> AstriDevCon 2015 </span> </a> </li> <li class=md-nav__item> <a href=../../AstriDevCon-2016/ class=md-nav__link> <span class=md-ellipsis> AstriDevCon 2016 </span> </a> </li> <li class=md-nav__item> <a href=../../AstriDevCon-2017/ class=md-nav__link> <span class=md-ellipsis> AstriDevCon 2017 </span> </a> </li> <li class=md-nav__item> <a href=../../AstriDevCon-2022/ class=md-nav__link> <span class=md-ellipsis> AstriDevCon 2022 </span> </a> </li> <li class=md-nav__item> <a href=../../AstriDevCon-2024-December/ class=md-nav__link> <span class=md-ellipsis> AstriDevCon 2024 December </span> </a> </li> <li class=md-nav__item> <a href=../../AstriDevCon-2024/ class=md-nav__link> <span class=md-ellipsis> AstriDevCon 2024 </span> </a> </li> <li class=md-nav__item> <a href=../../AstriDevCon-2025-April/ class=md-nav__link> <span class=md-ellipsis> AstriDevCon 2025 April </span> </a> </li> <li class=md-nav__item> <a href=../../AstriDevCon-2025-July/ class=md-nav__link> <span class=md-ellipsis> AstriDevCon 2025 July </span> </a> </li> <li class=md-nav__item> <a href=../../AstriDevCon-2025-November/ class=md-nav__link> <span class=md-ellipsis> AstriDevCon 2025 November </span> </a> </li> <li class=md-nav__item> <a href=../../AstriDevCon/ class=md-nav__link> <span class=md-ellipsis> AstriDevCon </span> </a> </li> <li class=md-nav__item> <a href=../../Astricon-2021-Presentation-attachments/ class=md-nav__link> <span class=md-ellipsis> Astricon 2021 Presentation attachments </span> </a> </li> <li class=md-nav__item> <a href=../../FOSDEM-2011-Open-Source-Telephony-Devroom/ class=md-nav__link> <span class=md-ellipsis> FOSDEM 2011 Open Source Telephony Devroom </span> </a> </li> <li class=md-nav__item> <a href=../../OpenSIPit-2021/ class=md-nav__link> <span class=md-ellipsis> OpenSIPit 2021 </span> </a> </li> <li class="md-nav__item md-nav__item--active md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_8_5_21 checked> <div class="md-nav__link md-nav__container"> <a href=../ class="md-nav__link "> <span class=md-ellipsis> Asterisk 10 Projects </span> </a> <label class="md-nav__link " for=__nav_8_5_21 id=__nav_8_5_21_label tabindex=0> <span class="md-nav__icon md-icon"></span> </label> </div> <nav class=md-nav data-md-level=3 aria-labelledby=__nav_8_5_21_label aria-expanded=true> <label class=md-nav__title for=__nav_8_5_21> <span class="md-nav__icon md-icon"></span> Asterisk 10 Projects </label> <ul class=md-nav__list data-md-scrollfix> <li class="md-nav__item md-nav__item--active"> <input class="md-nav__toggle md-toggle" type=checkbox id=__toc> <a href=./ class="md-nav__link md-nav__link--active"> <span class=md-ellipsis> Media Architecture Proposal </span> </a> </li> <li class=md-nav__item> <a href=../Media-Overhaul/ class=md-nav__link> <span class=md-ellipsis> Media Overhaul </span> </a> </li> <li class=md-nav__item> <a href=../chan_sip-Transaction-Support-Proprosal/ class=md-nav__link> <span class=md-ellipsis> chan_sip Transaction Support Proprosal </span> </a> </li> <li class="md-nav__item md-nav__item--pruned md-nav__item--nested"> <a href=../Codecs-and-Audio-Formats/ class=md-nav__link> <span class=md-ellipsis> Codecs and Audio Formats </span> <span class="md-nav__icon md-icon"></span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--pruned md-nav__item--nested"> <a href=../../Asterisk-11-Projects/ class=md-nav__link> <span class=md-ellipsis> Asterisk 11 Projects </span> <span class="md-nav__icon md-icon"></span> </a> </li> <li class="md-nav__item md-nav__item--pruned md-nav__item--nested"> <a href=../../Asterisk-12-Projects/ class=md-nav__link> <span class=md-ellipsis> Asterisk 12 Projects </span> <span class="md-nav__icon md-icon"></span> </a> </li> <li class="md-nav__item md-nav__item--pruned md-nav__item--nested"> <a href=../../Asterisk-13-Projects/ class=md-nav__link> <span class=md-ellipsis> Asterisk 13 Projects </span> <span class="md-nav__icon md-icon"></span> </a> </li> <li class="md-nav__item md-nav__item--pruned md-nav__item--nested"> <a href=../../Asterisk-14-Projects/ class=md-nav__link> <span class=md-ellipsis> Asterisk 14 Projects </span> <span class="md-nav__icon md-icon"></span> </a> </li> <li class="md-nav__item md-nav__item--pruned md-nav__item--nested"> <a href=../../Asterisk-15-Projects/ class=md-nav__link> <span class=md-ellipsis> Asterisk 15 Projects </span> <span class="md-nav__icon md-icon"></span> </a> </li> <li class="md-nav__item md-nav__item--pruned md-nav__item--nested"> <a href=../../Asterisk-16-Projects/ class=md-nav__link> <span class=md-ellipsis> Asterisk 16 Projects </span> <span class="md-nav__icon md-icon"></span> </a> </li> <li class="md-nav__item md-nav__item--pruned md-nav__item--nested"> <a href=../../Asterisk-18-Projects/ class=md-nav__link> <span class=md-ellipsis> Asterisk 18 Projects </span> <span class="md-nav__icon md-icon"></span> </a> </li> <li class="md-nav__item md-nav__item--pruned md-nav__item--nested"> <a href=../../Asterisk-19-Projects/ class=md-nav__link> <span class=md-ellipsis> Asterisk 19 Projects </span> <span class="md-nav__icon md-icon"></span> </a> </li> <li class="md-nav__item md-nav__item--pruned md-nav__item--nested"> <a href=../../AstriDevCon-2018/ class=md-nav__link> <span class=md-ellipsis> AstriDevCon 2018 </span> <span class="md-nav__icon md-icon"></span> </a> </li> <li class="md-nav__item md-nav__item--pruned md-nav__item--nested"> <a href=../../AstriDevCon-2019/ class=md-nav__link> <span class=md-ellipsis> AstriDevCon 2019 </span> <span class="md-nav__icon md-icon"></span> </a> </li> <li class="md-nav__item md-nav__item--pruned md-nav__item--nested"> <a href=../../AstriDevCon-2020/ class=md-nav__link> <span class=md-ellipsis> AstriDevCon 2020 </span> <span class="md-nav__icon md-icon"></span> </a> </li> <li class="md-nav__item md-nav__item--pruned md-nav__item--nested"> <a href=../../AstriDevCon-2021/ class=md-nav__link> <span class=md-ellipsis> AstriDevCon 2021 </span> <span class="md-nav__icon md-icon"></span> </a> </li> <li class="md-nav__item md-nav__item--pruned md-nav__item--nested"> <a href=../../Future-Potential-Project-Thoughts/ class=md-nav__link> <span class=md-ellipsis> Future Potential Project Thoughts </span> <span class="md-nav__icon md-icon"></span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=../../../Asterisk-Bug-Bounties/ class=md-nav__link> <span class=md-ellipsis> Asterisk Bug Bounties </span> </a> </li> <li class=md-nav__item> <a href=../../../Asterisk-C-API-Deprecations/ class=md-nav__link> <span class=md-ellipsis> Asterisk C API Deprecations </span> </a> </li> <li class=md-nav__item> <a href=../../../Asterisk-Module-Deprecations/ class=md-nav__link> <span class=md-ellipsis> Asterisk Module Deprecations </span> </a> </li> <li class=md-nav__item> <a href=../../../Asterisk-Open-Source-Maintainers/ class=md-nav__link> <span class=md-ellipsis> Asterisk Open Source Maintainers </span> </a> </li> <li class=md-nav__item> <a href=../../../Open-Features-and-Improvements/ class=md-nav__link> <span class=md-ellipsis> Open Features and Improvements </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--pruned md-nav__item--nested"> <a href=../../../../Latest_API/ class=md-nav__link> <span class=md-ellipsis> Latest API </span> <span class="md-nav__icon md-icon"></span> </a> </li> <li class="md-nav__item md-nav__item--pruned md-nav__item--nested"> <a href=../../../../Asterisk_18_Documentation/ class=md-nav__link> <span class=md-ellipsis> Asterisk 18 Documentation </span> <span class="md-nav__icon md-icon"></span> </a> </li> <li class="md-nav__item md-nav__item--pruned md-nav__item--nested"> <a href=../../../../Asterisk_19_Documentation/ class=md-nav__link> <span class=md-ellipsis> Asterisk 19 Documentation </span> <span class="md-nav__icon md-icon"></span> </a> </li> <li class="md-nav__item md-nav__item--pruned md-nav__item--nested"> <a href=../../../../Asterisk_20_Documentation/ class=md-nav__link> <span class=md-ellipsis> Asterisk 20 Documentation </span> <span class="md-nav__icon md-icon"></span> </a> </li> <li class="md-nav__item md-nav__item--pruned md-nav__item--nested"> <a href=../../../../Asterisk_21_Documentation/ class=md-nav__link> <span class=md-ellipsis> Asterisk 21 Documentation </span> <span class="md-nav__icon md-icon"></span> </a> </li> <li class="md-nav__item md-nav__item--pruned md-nav__item--nested"> <a href=../../../../Asterisk_22_Documentation/ class=md-nav__link> <span class=md-ellipsis> Asterisk 22 Documentation </span> <span class="md-nav__icon md-icon"></span> </a> </li> <li class="md-nav__item md-nav__item--pruned md-nav__item--nested"> <a href=../../../../Asterisk_23_Documentation/ class=md-nav__link> <span class=md-ellipsis> Asterisk 23 Documentation </span> <span class="md-nav__icon md-icon"></span> </a> </li> <li class="md-nav__item md-nav__item--pruned md-nav__item--nested"> <a href=../../../../Certified-Asterisk_18.9_Documentation/ class=md-nav__link> <span class=md-ellipsis> Certified Asterisk 18.9 Documentation </span> <span class="md-nav__icon md-icon"></span> </a> </li> <li class="md-nav__item md-nav__item--pruned md-nav__item--nested"> <a href=../../../../Certified-Asterisk_20.7_Documentation/ class=md-nav__link> <span class=md-ellipsis> Certified Asterisk 20.7 Documentation </span> <span class="md-nav__icon md-icon"></span> </a> </li> <li class="md-nav__item md-nav__item--pruned md-nav__item--nested"> <a href=../../../../Test-Suite-Documentation/ class=md-nav__link> <span class=md-ellipsis> Test Suite Documentation </span> <span class="md-nav__icon md-icon"></span> </a> </li> <li class="md-nav__item md-nav__item--pruned md-nav__item--nested"> <a href=../../../../Historical-Documentation/ class=md-nav__link> <span class=md-ellipsis> Historical Documentation </span> <span class="md-nav__icon md-icon"></span> </a> </li> <li class=md-nav__item> <a href=../../../../Contributing-to-the-Documentation/ class=md-nav__link> <span class=md-ellipsis> Contributing to the Documentation </span> </a> </li> </ul> </nav> </div> </div> </div> <div class="md-sidebar md-sidebar--secondary" data-md-component=sidebar data-md-type=toc> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--secondary" aria-label="Table of contents"> </nav> </div> </div> </div> <div class=md-content data-md-component=content> <article class="md-content__inner md-typeset"> <h1 id=introduction>Introduction<a class=headerlink href=#introduction title="Permanent link">&para;</a></h1> <p>Asterisk was written from the ground up with a set of assumptions about how media is represented and negotiated. These assumptions have worked to get Asterisk where it is today, but unfortunately they have also put in place a set of limitations that must be overcome before Asterisk can meet the demands of the future. While these limitations are built into the foundation of Asterisk's design, the necessary changes required to lift these constraints can be made. This document outlines the required changes and breaks them up into a layered approach. Each section addresses a specific problem with Asterisk's current media architecture and proposes a solution. As the sections progress each new section uses the foundation outlined in the previous sections to address an increasingly complex set of problems. By attacking this issue from the foundation up it is possible to generate a complete solution that exceeds the current development constraints opening Asterisk up to an entire new set of possibilities.</p> <h1 id=table-of-contents>Table of Contents<a class=headerlink href=#table-of-contents title="Permanent link">&para;</a></h1> <p>{toc:style=disc|indent=20px}</p> <h1 id=project-requirements>Project Requirements<a class=headerlink href=#project-requirements title="Permanent link">&para;</a></h1> <ul> <li>Lift the limit placed on the number of media formats Asterisk can support.</li> <li>Add the ability for Asterisk to represent media formats with attributes.<ul> <li>Support for SILK with attributes</li> <li>Support for H.264 with attributes</li> </ul> </li> <li>Add the ability for Asterisk to negotiate media formats with attributes.</li> <li>Allow translation paths to be built between all media types, not just audio.</li> <li>Allow translation paths to be built in a way that takes into account both media quality and translation cost for all media formats.</li> <li>Allow a channel to process multiple media streams, even of the same media type, with translation.</li> <li>Support the ability to renegotiate media formats after call setup is complete.</li> <li>Support the ability to pass-through media Asterisk does not yet understand.</li> <li>Support the ability to for users to specify media formats with attributes in .conf files.</li> </ul> <h1 id=representation-of-media-formats>Representation of Media Formats<a class=headerlink href=#representation-of-media-formats title="Permanent link">&para;</a></h1> <h2 id=problem-overview>Problem Overview<a class=headerlink href=#problem-overview title="Permanent link">&para;</a></h2> <p>One of the key problems the new media architecture must address is how to represent a media format that does not have statically defined parameters. In the past, simply defining a media format type as uLaw or g722 posed no problem as these formats have a very specific set of parameters associated with them. For example uLaw is always 8khz, each sample is always the exact same size, and there is really nothing more required to describe a uLaw payload other than now large it is. Everything else can be calculated because parameters for uLaw payloads never change. Unfortunately the assumption that media formats do not need to be defined beyond their format type has proven to be a limitation in the ability to adopt modern media formats. The problems prohibiting integration of feature complete SILK codec support into Asterisk offers a prime example of how this limitation is hindering development. SILK is an audio codec that may adjust the sample rate used in a stream based upon the capabilities of the network. Right now Asterisk assumes every media format will always contain the same sample rate. Without the ability to define a format's sample rate outside of the hard coded rate defined at compile time, implementing SILK into Asterisk without limiting the codec's functionality is not currently possible.</p> <p>In order to address this limitation, media formats will have the ability to be further defined using format specific attribute structures. These structures along with usage examples are outlined in below.</p> <h2 id=introducing-ast_format-the-new-and-improved-format_t>Introducing ast_format, The New and Improved format_t<a class=headerlink href=#introducing-ast_format-the-new-and-improved-format_t title="Permanent link">&para;</a></h2> <p>The ast_format structure completely replaces format_t everywhere in the code. This new structure allows for a format to be represented not only by a unique ID, but with an attribute structure as well. This means if a channel's read format is SILK and it understands 8khz-&gt;16khz without the need of translation, this can be now represented using only a single format identifier. In this case the ast_format's uid would be AST_FORMAT_SILK, and the attribute structure would be configured to further define this format as having a possible dynamic sample rate between 8khz and 16khz.</p> <p>The ast_format structure on an ast_frame has a slightly different behavior than representing a read and write format though. When on a frame the attributes structure must be used only to further define the frame's payload. In the SILK read format example discussed above, the attribute structure is used to represent a sample rate range the channel's read format is capable of understanding without translation, but when the attribute structure is used on a frame it must represent a very precise set of parameters directly related to the media payload being transported. In the case of SILK, the attribute structure on a frame would represent precisely what sample rate the payload contains.</p> <h2 id=the-ast-format-api>The Ast Format API<a class=headerlink href=#the-ast-format-api title="Permanent link">&para;</a></h2> <div class="language-text highlight"><pre><span></span><code><span id=__span-0-1><a id=__codelineno-0-1 name=__codelineno-0-1 href=#__codelineno-0-1></a>/*! \brief This structure contains the buffer used for format attribute */
</span><span id=__span-0-2><a id=__codelineno-0-2 name=__codelineno-0-2 href=#__codelineno-0-2></a>struct ast_format_attr {
</span><span id=__span-0-3><a id=__codelineno-0-3 name=__codelineno-0-3 href=#__codelineno-0-3></a> uint8_t format_attr[AST_FORMATNEW_ATTR_SIZE];
</span><span id=__span-0-4><a id=__codelineno-0-4 name=__codelineno-0-4 href=#__codelineno-0-4></a>};
</span><span id=__span-0-5><a id=__codelineno-0-5 name=__codelineno-0-5 href=#__codelineno-0-5></a>
</span><span id=__span-0-6><a id=__codelineno-0-6 name=__codelineno-0-6 href=#__codelineno-0-6></a>/*! \brief Represents a media format within Asterisk */
</span><span id=__span-0-7><a id=__codelineno-0-7 name=__codelineno-0-7 href=#__codelineno-0-7></a>struct ast_format {
</span><span id=__span-0-8><a id=__codelineno-0-8 name=__codelineno-0-8 href=#__codelineno-0-8></a> /*! The unique id representing this format from all the other formats */
</span><span id=__span-0-9><a id=__codelineno-0-9 name=__codelineno-0-9 href=#__codelineno-0-9></a> enum ast_format_id id;
</span><span id=__span-0-10><a id=__codelineno-0-10 name=__codelineno-0-10 href=#__codelineno-0-10></a> /*! Attribute structure used to associate attributes with a format */
</span><span id=__span-0-11><a id=__codelineno-0-11 name=__codelineno-0-11 href=#__codelineno-0-11></a> struct ast_format_attr fattr;
</span><span id=__span-0-12><a id=__codelineno-0-12 name=__codelineno-0-12 href=#__codelineno-0-12></a>};
</span><span id=__span-0-13><a id=__codelineno-0-13 name=__codelineno-0-13 href=#__codelineno-0-13></a>
</span><span id=__span-0-14><a id=__codelineno-0-14 name=__codelineno-0-14 href=#__codelineno-0-14></a>enum ast_format_cmp_res {
</span><span id=__span-0-15><a id=__codelineno-0-15 name=__codelineno-0-15 href=#__codelineno-0-15></a> /*! structure 1 is identical to structure 2 */
</span><span id=__span-0-16><a id=__codelineno-0-16 name=__codelineno-0-16 href=#__codelineno-0-16></a> AST_FORMAT_CMP_EQUAL = 0,
</span><span id=__span-0-17><a id=__codelineno-0-17 name=__codelineno-0-17 href=#__codelineno-0-17></a> /*! structure 1 contains elements not in structure 2 */
</span><span id=__span-0-18><a id=__codelineno-0-18 name=__codelineno-0-18 href=#__codelineno-0-18></a> AST_FORMAT_CMP_NOT_EQUAL,
</span><span id=__span-0-19><a id=__codelineno-0-19 name=__codelineno-0-19 href=#__codelineno-0-19></a> /*! structure 1 is a proper subset of the elements in structure 2. */
</span><span id=__span-0-20><a id=__codelineno-0-20 name=__codelineno-0-20 href=#__codelineno-0-20></a> AST_FORMAT_CMP_SUBSET,
</span><span id=__span-0-21><a id=__codelineno-0-21 name=__codelineno-0-21 href=#__codelineno-0-21></a>};
</span><span id=__span-0-22><a id=__codelineno-0-22 name=__codelineno-0-22 href=#__codelineno-0-22></a>
</span><span id=__span-0-23><a id=__codelineno-0-23 name=__codelineno-0-23 href=#__codelineno-0-23></a>/*!
</span><span id=__span-0-24><a id=__codelineno-0-24 name=__codelineno-0-24 href=#__codelineno-0-24></a> * \brief This function is used to set an ast_format object to represent a media format
</span><span id=__span-0-25><a id=__codelineno-0-25 name=__codelineno-0-25 href=#__codelineno-0-25></a> * with optional format attributes represented by format specific key value pairs.
</span><span id=__span-0-26><a id=__codelineno-0-26 name=__codelineno-0-26 href=#__codelineno-0-26></a> *
</span><span id=__span-0-27><a id=__codelineno-0-27 name=__codelineno-0-27 href=#__codelineno-0-27></a> * \param format to set
</span><span id=__span-0-28><a id=__codelineno-0-28 name=__codelineno-0-28 href=#__codelineno-0-28></a> * \param id, format id to set on format
</span><span id=__span-0-29><a id=__codelineno-0-29 name=__codelineno-0-29 href=#__codelineno-0-29></a> * \param set_attributes, are there attributes to set on this format. 0 == false, 1 == True.
</span><span id=__span-0-30><a id=__codelineno-0-30 name=__codelineno-0-30 href=#__codelineno-0-30></a> * \param var list of attribute key value pairs, must end with AST_FORMATNEW_ATTR_END;
</span><span id=__span-0-31><a id=__codelineno-0-31 name=__codelineno-0-31 href=#__codelineno-0-31></a> *
</span><span id=__span-0-32><a id=__codelineno-0-32 name=__codelineno-0-32 href=#__codelineno-0-32></a> * \details Example usage.
</span><span id=__span-0-33><a id=__codelineno-0-33 name=__codelineno-0-33 href=#__codelineno-0-33></a> * ast_format_set(format, AST_FORMATNEW_ULAW, 0); // no capability attributes are needed for ULAW
</span><span id=__span-0-34><a id=__codelineno-0-34 name=__codelineno-0-34 href=#__codelineno-0-34></a> *
</span><span id=__span-0-35><a id=__codelineno-0-35 name=__codelineno-0-35 href=#__codelineno-0-35></a> * ast_format_set(format, AST_FORMATNEW_SILK, 1, // SILK has capability attributes.
</span><span id=__span-0-36><a id=__codelineno-0-36 name=__codelineno-0-36 href=#__codelineno-0-36></a> * AST_FORMATNEW_SILK_ATTR_RATE, 24000,
</span><span id=__span-0-37><a id=__codelineno-0-37 name=__codelineno-0-37 href=#__codelineno-0-37></a> * AST_FORMATNEW_SILK_ATTR_RATE, 16000,
</span><span id=__span-0-38><a id=__codelineno-0-38 name=__codelineno-0-38 href=#__codelineno-0-38></a> * AST_FORMATNEW_SILK_ATTR_RATE, 12000,
</span><span id=__span-0-39><a id=__codelineno-0-39 name=__codelineno-0-39 href=#__codelineno-0-39></a> * AST_FORMATNEW_SILK_ATTR_RATE, 8000,
</span><span id=__span-0-40><a id=__codelineno-0-40 name=__codelineno-0-40 href=#__codelineno-0-40></a> * AST_FORMATNEW_ATTR_END);
</span><span id=__span-0-41><a id=__codelineno-0-41 name=__codelineno-0-41 href=#__codelineno-0-41></a> *
</span><span id=__span-0-42><a id=__codelineno-0-42 name=__codelineno-0-42 href=#__codelineno-0-42></a> * \return Pointer to ast_format object, same pointer that is passed in
</span><span id=__span-0-43><a id=__codelineno-0-43 name=__codelineno-0-43 href=#__codelineno-0-43></a> * by the first argument.
</span><span id=__span-0-44><a id=__codelineno-0-44 name=__codelineno-0-44 href=#__codelineno-0-44></a> */
</span><span id=__span-0-45><a id=__codelineno-0-45 name=__codelineno-0-45 href=#__codelineno-0-45></a>struct ast_format *ast_format_set(struct ast_format *format, enum ast_format_id id, int set_attributes, ... );
</span><span id=__span-0-46><a id=__codelineno-0-46 name=__codelineno-0-46 href=#__codelineno-0-46></a>
</span><span id=__span-0-47><a id=__codelineno-0-47 name=__codelineno-0-47 href=#__codelineno-0-47></a>/*!
</span><span id=__span-0-48><a id=__codelineno-0-48 name=__codelineno-0-48 href=#__codelineno-0-48></a> * \brief This function is used to set an ast_format object to represent a media format
</span><span id=__span-0-49><a id=__codelineno-0-49 name=__codelineno-0-49 href=#__codelineno-0-49></a> * with optional capability attributes represented by format specific key value pairs.
</span><span id=__span-0-50><a id=__codelineno-0-50 name=__codelineno-0-50 href=#__codelineno-0-50></a> *
</span><span id=__span-0-51><a id=__codelineno-0-51 name=__codelineno-0-51 href=#__codelineno-0-51></a> * \details Example usage. Is this SILK format capable of 8khz
</span><span id=__span-0-52><a id=__codelineno-0-52 name=__codelineno-0-52 href=#__codelineno-0-52></a> * is_8khz = ast_format_isset(format, AST_FORMATNEW_SILK_CAP_RATE, 8000);
</span><span id=__span-0-53><a id=__codelineno-0-53 name=__codelineno-0-53 href=#__codelineno-0-53></a> *
</span><span id=__span-0-54><a id=__codelineno-0-54 name=__codelineno-0-54 href=#__codelineno-0-54></a> * \return 0, The format key value pairs are within the capabilities defined in this structure.
</span><span id=__span-0-55><a id=__codelineno-0-55 name=__codelineno-0-55 href=#__codelineno-0-55></a> * \return -1, The format key value pairs are _NOT_ within the capabilities of this structure.
</span><span id=__span-0-56><a id=__codelineno-0-56 name=__codelineno-0-56 href=#__codelineno-0-56></a> */
</span><span id=__span-0-57><a id=__codelineno-0-57 name=__codelineno-0-57 href=#__codelineno-0-57></a>int ast_format_isset(struct ast_format *format, ... );
</span><span id=__span-0-58><a id=__codelineno-0-58 name=__codelineno-0-58 href=#__codelineno-0-58></a>
</span><span id=__span-0-59><a id=__codelineno-0-59 name=__codelineno-0-59 href=#__codelineno-0-59></a>/*!
</span><span id=__span-0-60><a id=__codelineno-0-60 name=__codelineno-0-60 href=#__codelineno-0-60></a> * \brief Compare ast_formats structures
</span><span id=__span-0-61><a id=__codelineno-0-61 name=__codelineno-0-61 href=#__codelineno-0-61></a> *
</span><span id=__span-0-62><a id=__codelineno-0-62 name=__codelineno-0-62 href=#__codelineno-0-62></a> * \retval ast_format_cmp_res representing the result of comparing format1 and format2.
</span><span id=__span-0-63><a id=__codelineno-0-63 name=__codelineno-0-63 href=#__codelineno-0-63></a> */
</span><span id=__span-0-64><a id=__codelineno-0-64 name=__codelineno-0-64 href=#__codelineno-0-64></a>enum ast_format_cmp_res ast_format_cmp(struct ast_format *format1, struct ast_format *format2);
</span><span id=__span-0-65><a id=__codelineno-0-65 name=__codelineno-0-65 href=#__codelineno-0-65></a>
</span><span id=__span-0-66><a id=__codelineno-0-66 name=__codelineno-0-66 href=#__codelineno-0-66></a>/*!
</span><span id=__span-0-67><a id=__codelineno-0-67 name=__codelineno-0-67 href=#__codelineno-0-67></a> * \brief Find joint format attributes of two ast_format
</span><span id=__span-0-68><a id=__codelineno-0-68 name=__codelineno-0-68 href=#__codelineno-0-68></a> * structures containing the same uid and return the intersection in the
</span><span id=__span-0-69><a id=__codelineno-0-69 name=__codelineno-0-69 href=#__codelineno-0-69></a> * result structure.
</span><span id=__span-0-70><a id=__codelineno-0-70 name=__codelineno-0-70 href=#__codelineno-0-70></a> *
</span><span id=__span-0-71><a id=__codelineno-0-71 name=__codelineno-0-71 href=#__codelineno-0-71></a> * retval 0, joint attribute capabilities exist.
</span><span id=__span-0-72><a id=__codelineno-0-72 name=__codelineno-0-72 href=#__codelineno-0-72></a> * retval -1, no joint attribute capabilities exist.
</span><span id=__span-0-73><a id=__codelineno-0-73 name=__codelineno-0-73 href=#__codelineno-0-73></a> */
</span><span id=__span-0-74><a id=__codelineno-0-74 name=__codelineno-0-74 href=#__codelineno-0-74></a>int ast_format_joint(struct ast_format *format1, struct ast_format *format2, struct ast_format *result);
</span><span id=__span-0-75><a id=__codelineno-0-75 name=__codelineno-0-75 href=#__codelineno-0-75></a>
</span><span id=__span-0-76><a id=__codelineno-0-76 name=__codelineno-0-76 href=#__codelineno-0-76></a>/*!
</span><span id=__span-0-77><a id=__codelineno-0-77 name=__codelineno-0-77 href=#__codelineno-0-77></a> * \brief copy format src into format dst.
</span><span id=__span-0-78><a id=__codelineno-0-78 name=__codelineno-0-78 href=#__codelineno-0-78></a> */
</span><span id=__span-0-79><a id=__codelineno-0-79 name=__codelineno-0-79 href=#__codelineno-0-79></a>void ast_format_copy(struct ast_format *src, struct ast_format *dst);
</span><span id=__span-0-80><a id=__codelineno-0-80 name=__codelineno-0-80 href=#__codelineno-0-80></a>
</span><span id=__span-0-81><a id=__codelineno-0-81 name=__codelineno-0-81 href=#__codelineno-0-81></a>/*!
</span><span id=__span-0-82><a id=__codelineno-0-82 name=__codelineno-0-82 href=#__codelineno-0-82></a> * \brief ast_format to iax2 bitfield format represenatation
</span><span id=__span-0-83><a id=__codelineno-0-83 name=__codelineno-0-83 href=#__codelineno-0-83></a> *
</span><span id=__span-0-84><a id=__codelineno-0-84 name=__codelineno-0-84 href=#__codelineno-0-84></a> * \note This is only to be used for IAX2 compatibility 
</span><span id=__span-0-85><a id=__codelineno-0-85 name=__codelineno-0-85 href=#__codelineno-0-85></a> *
</span><span id=__span-0-86><a id=__codelineno-0-86 name=__codelineno-0-86 href=#__codelineno-0-86></a> * \retval iax2 representation of ast_format
</span><span id=__span-0-87><a id=__codelineno-0-87 name=__codelineno-0-87 href=#__codelineno-0-87></a> * \retval 0, if no representation existis for iax2
</span><span id=__span-0-88><a id=__codelineno-0-88 name=__codelineno-0-88 href=#__codelineno-0-88></a> */
</span><span id=__span-0-89><a id=__codelineno-0-89 name=__codelineno-0-89 href=#__codelineno-0-89></a>uint64_t ast_format_to_iax2(struct ast_format *format);
</span><span id=__span-0-90><a id=__codelineno-0-90 name=__codelineno-0-90 href=#__codelineno-0-90></a>
</span><span id=__span-0-91><a id=__codelineno-0-91 name=__codelineno-0-91 href=#__codelineno-0-91></a>/*!
</span><span id=__span-0-92><a id=__codelineno-0-92 name=__codelineno-0-92 href=#__codelineno-0-92></a> * \brief convert iax2 bitfield format to ast_format represenatation
</span><span id=__span-0-93><a id=__codelineno-0-93 name=__codelineno-0-93 href=#__codelineno-0-93></a> * \note This is only to be used for IAX2 compatibility 
</span><span id=__span-0-94><a id=__codelineno-0-94 name=__codelineno-0-94 href=#__codelineno-0-94></a> *
</span><span id=__span-0-95><a id=__codelineno-0-95 name=__codelineno-0-95 href=#__codelineno-0-95></a> * \retval on success, pointer to the dst format in the input parameters
</span><span id=__span-0-96><a id=__codelineno-0-96 name=__codelineno-0-96 href=#__codelineno-0-96></a> * \retval on failure, NULL
</span><span id=__span-0-97><a id=__codelineno-0-97 name=__codelineno-0-97 href=#__codelineno-0-97></a> */
</span><span id=__span-0-98><a id=__codelineno-0-98 name=__codelineno-0-98 href=#__codelineno-0-98></a>struct ast_format *ast_format_from_iax2(uint64_t src, struct ast_format *dst);
</span></code></pre></div> <h2 id=introducing-the-format-attribute-structure>Introducing the Format Attribute Structure<a class=headerlink href=#introducing-the-format-attribute-structure title="Permanent link">&para;</a></h2> <p>The attribute structure is present on every ast_format object. This attribute structure is an opaque buffer that can be used in anyway necessary by the format it represents. Since it will be necessary for Asterisk to perform a few generic operations on these attribute structures, every format requiring the use of the attribute structure must implement and register a format attribute interface with Asterisk. These registered interfaces are used by the Ast Format API allowing for attributes on an ast_format structure to be set, removed, and compared using a single set of API functions for all format types. The Ast Format API does all the work of finding the correct interface to use and calling the correct interface functions.</p> <p>The size of the buffer in the attribute structure was determined by researching the media format with the largest number of attributes expected to be present in Asterisk 10. In this case the H.264 SVC draft was used, which is an expanded form of RFC 3984 allowing for some additional functionality. The attributes required by H.264 SVC are determined based upon the SDP parameters defined in the draft. The SDP parameters used by the draft do not all have fixed sizes, but it was determined that an attribute buffer of ~70 bytes will easily suffice for representing the most common use cases. In order to account for undefined future development, this buffer is initially set at 128 bytes which satisfies the current estimated attribute size requirements.</p> <h2 id=the-ast-format-attribute-api>The Ast Format Attribute API<a class=headerlink href=#the-ast-format-attribute-api title="Permanent link">&para;</a></h2> <div class="language-text highlight"><pre><span></span><code><span id=__span-1-1><a id=__codelineno-1-1 name=__codelineno-1-1 href=#__codelineno-1-1></a>#define AST_FORMAT_ATTR_SIZE 128
</span><span id=__span-1-2><a id=__codelineno-1-2 name=__codelineno-1-2 href=#__codelineno-1-2></a>
</span><span id=__span-1-3><a id=__codelineno-1-3 name=__codelineno-1-3 href=#__codelineno-1-3></a>struct ast_format_attr {
</span><span id=__span-1-4><a id=__codelineno-1-4 name=__codelineno-1-4 href=#__codelineno-1-4></a> uint8_t format_attr[AST_FORMAT_FORMAT_ATTR_SIZE];
</span><span id=__span-1-5><a id=__codelineno-1-5 name=__codelineno-1-5 href=#__codelineno-1-5></a>}
</span><span id=__span-1-6><a id=__codelineno-1-6 name=__codelineno-1-6 href=#__codelineno-1-6></a>
</span><span id=__span-1-7><a id=__codelineno-1-7 name=__codelineno-1-7 href=#__codelineno-1-7></a>/*! \brief A format must register an attribute interface if it requires the use of the format attributes void pointe */
</span><span id=__span-1-8><a id=__codelineno-1-8 name=__codelineno-1-8 href=#__codelineno-1-8></a>struct ast_format_attr_interface {
</span><span id=__span-1-9><a id=__codelineno-1-9 name=__codelineno-1-9 href=#__codelineno-1-9></a> /*! format typ */
</span><span id=__span-1-10><a id=__codelineno-1-10 name=__codelineno-1-10 href=#__codelineno-1-10></a> enum ast_format_id id;
</span><span id=__span-1-11><a id=__codelineno-1-11 name=__codelineno-1-11 href=#__codelineno-1-11></a>
</span><span id=__span-1-12><a id=__codelineno-1-12 name=__codelineno-1-12 href=#__codelineno-1-12></a> /*! \brief Determine if format_attr 1 is a subset of format_attr 2.
</span><span id=__span-1-13><a id=__codelineno-1-13 name=__codelineno-1-13 href=#__codelineno-1-13></a> *
</span><span id=__span-1-14><a id=__codelineno-1-14 name=__codelineno-1-14 href=#__codelineno-1-14></a> * \retval ast_format_cmp_res representing the result of comparing fattr1 and fattr2.
</span><span id=__span-1-15><a id=__codelineno-1-15 name=__codelineno-1-15 href=#__codelineno-1-15></a> */
</span><span id=__span-1-16><a id=__codelineno-1-16 name=__codelineno-1-16 href=#__codelineno-1-16></a> enum ast_format_cmp_res (* const format_attr_cmp)(struct ast_format_attr *fattr1, struct ast_format_attr *fattr2);
</span><span id=__span-1-17><a id=__codelineno-1-17 name=__codelineno-1-17 href=#__codelineno-1-17></a>
</span><span id=__span-1-18><a id=__codelineno-1-18 name=__codelineno-1-18 href=#__codelineno-1-18></a> /*! \brief Get joint attributes of same format type if they exist.
</span><span id=__span-1-19><a id=__codelineno-1-19 name=__codelineno-1-19 href=#__codelineno-1-19></a> *
</span><span id=__span-1-20><a id=__codelineno-1-20 name=__codelineno-1-20 href=#__codelineno-1-20></a> * \retval 0 if joint attributes exist
</span><span id=__span-1-21><a id=__codelineno-1-21 name=__codelineno-1-21 href=#__codelineno-1-21></a> * \retval -1 if no joint attributes are present
</span><span id=__span-1-22><a id=__codelineno-1-22 name=__codelineno-1-22 href=#__codelineno-1-22></a> */
</span><span id=__span-1-23><a id=__codelineno-1-23 name=__codelineno-1-23 href=#__codelineno-1-23></a> int (* const format_attr_get_joint)(struct ast_format_attr *fattr1, struct ast_format_attr *fattr2, struct ast_format_attr *result);
</span><span id=__span-1-24><a id=__codelineno-1-24 name=__codelineno-1-24 href=#__codelineno-1-24></a>
</span><span id=__span-1-25><a id=__codelineno-1-25 name=__codelineno-1-25 href=#__codelineno-1-25></a> /*! \brief Set format capabilities from a list of key value pairs ending with AST_FORMAT_ATTR_END.
</span><span id=__span-1-26><a id=__codelineno-1-26 name=__codelineno-1-26 href=#__codelineno-1-26></a> * \note This function is expected to call va_end(ap) after processing the va_list */
</span><span id=__span-1-27><a id=__codelineno-1-27 name=__codelineno-1-27 href=#__codelineno-1-27></a> void (* const format_attr_set)(struct ast_format_attr *format_attr, va_list ap);
</span><span id=__span-1-28><a id=__codelineno-1-28 name=__codelineno-1-28 href=#__codelineno-1-28></a>};
</span><span id=__span-1-29><a id=__codelineno-1-29 name=__codelineno-1-29 href=#__codelineno-1-29></a>
</span><span id=__span-1-30><a id=__codelineno-1-30 name=__codelineno-1-30 href=#__codelineno-1-30></a>/*! \brief register ast_format_attr_interface with core.
</span><span id=__span-1-31><a id=__codelineno-1-31 name=__codelineno-1-31 href=#__codelineno-1-31></a> *
</span><span id=__span-1-32><a id=__codelineno-1-32 name=__codelineno-1-32 href=#__codelineno-1-32></a> * \retval 0 success
</span><span id=__span-1-33><a id=__codelineno-1-33 name=__codelineno-1-33 href=#__codelineno-1-33></a> * \retval -1 failure
</span><span id=__span-1-34><a id=__codelineno-1-34 name=__codelineno-1-34 href=#__codelineno-1-34></a> */
</span><span id=__span-1-35><a id=__codelineno-1-35 name=__codelineno-1-35 href=#__codelineno-1-35></a>int ast_format_attr_reg_interface(struct ast_format_attr_interface *interface);
</span><span id=__span-1-36><a id=__codelineno-1-36 name=__codelineno-1-36 href=#__codelineno-1-36></a>
</span><span id=__span-1-37><a id=__codelineno-1-37 name=__codelineno-1-37 href=#__codelineno-1-37></a>/*!
</span><span id=__span-1-38><a id=__codelineno-1-38 name=__codelineno-1-38 href=#__codelineno-1-38></a> * \brief unregister format_attr interface with core.
</span><span id=__span-1-39><a id=__codelineno-1-39 name=__codelineno-1-39 href=#__codelineno-1-39></a> *
</span><span id=__span-1-40><a id=__codelineno-1-40 name=__codelineno-1-40 href=#__codelineno-1-40></a> * \retval 0 success
</span><span id=__span-1-41><a id=__codelineno-1-41 name=__codelineno-1-41 href=#__codelineno-1-41></a> * \retval -1 failure
</span><span id=__span-1-42><a id=__codelineno-1-42 name=__codelineno-1-42 href=#__codelineno-1-42></a> */
</span><span id=__span-1-43><a id=__codelineno-1-43 name=__codelineno-1-43 href=#__codelineno-1-43></a>int ast_format_attr_unreg_interface(struct ast_format_attr_interface *interface);
</span></code></pre></div> <h2 id=the-new-format-unique-identifier>The New Format Unique Identifier<a class=headerlink href=#the-new-format-unique-identifier title="Permanent link">&para;</a></h2> <p>Media formats in Asterisk are currently defined using a bit field, format_t, where every format is uniquely identified by a single bit. While this makes comparing media format capabilities extremely simple using bitwise operations, this representation limits the number of media formats that can be represented due to the limited size of the bit field in use. Even if a bit field could represent an infinite number of bits, this representation has no concept of how to compare format capability attributes.</p> <p>In order to remove the limitation of the number of unique formats that can be represented the identifier will change from a single bit representation to a numeric representation. This means that #define AST_FORMAT_ULAW (1 &lt;&lt; 0) now becomes #define AST_FORMAT_ULAW 1. By changing the way media formats are identified from a bit in a bit field to a numeric value, the limit on the number of formats that can be represented goes from 64 to 4,294,967,296. Altering this representation completely removes the ability to use bitwise operations on a bit field containing multiple media format capabilities, but since these bitwise operations lack the ability to process format attributes, they must be replaced by a more robust system anyway. The new system for computing joint media capabilities between peers hinted at here is discussed in detail in the Representation of Format Capabilities section.</p> <h2 id=format-unique-identifier-organization>Format Unique Identifier Organization<a class=headerlink href=#format-unique-identifier-organization title="Permanent link">&para;</a></h2> <p>The old system of using a single bit in a bit field to represent a single format also allows for bitmasks to be used to determine what type of media a format is categorized as. For example, there is a bitmask for determining if a format is an audio format, video format, or text format. By changing the unique id to a number the ability to use bitmasks to determine the category is no longer possible. Instead, a new convention of organizing these formats into media categories must be set in place.</p> <p>Since the number of formats that can be represented will likely never be exhausted using the new system, formats can be uniquely identified and categorized using a system that sections off each category into a range of numbers. Since it is unlikely any category will ever have even close to 100,000 unique formats associated with it, each category will be sectioned off by increments of 100,000. For example, all audio formats will be uniquely identified in a category between 100,000-199,999, all video formats will be uniquely identified in a category between 200,000-299,999, and so on for every category. This new system allows for each format's unique id to be overloaded with a category as well just like the previous system did. Instead of using a bitmask to determine if a format is video or audio, a function or macro can be used to do the comparison consistently across the code base.</p> <h2 id=new-format-unique-id-changes-to-frameh>New Format Unique Id Changes to frame.h<a class=headerlink href=#new-format-unique-id-changes-to-frameh title="Permanent link">&para;</a></h2> <p><div class="language-text highlight"><pre><span></span><code><span id=__span-2-1><a id=__codelineno-2-1 name=__codelineno-2-1 href=#__codelineno-2-1></a>/*OLD */
</span><span id=__span-2-2><a id=__codelineno-2-2 name=__codelineno-2-2 href=#__codelineno-2-2></a>#define AST_FORMAT_AUDIO_MASK 0xFFFF0000FFFFULL
</span><span id=__span-2-3><a id=__codelineno-2-3 name=__codelineno-2-3 href=#__codelineno-2-3></a>#define AST_FORMAT_G723_1 (1ULL &lt;&lt; 0)
</span><span id=__span-2-4><a id=__codelineno-2-4 name=__codelineno-2-4 href=#__codelineno-2-4></a>#define AST_FORMAT_GSM (1ULL &lt;&lt; 1)
</span><span id=__span-2-5><a id=__codelineno-2-5 name=__codelineno-2-5 href=#__codelineno-2-5></a>#define AST_FORMAT_ULAW (1ULL &lt;&lt; 2)
</span><span id=__span-2-6><a id=__codelineno-2-6 name=__codelineno-2-6 href=#__codelineno-2-6></a>#define AST_FORMAT_ALAW (1ULL &lt;&lt; 3)
</span><span id=__span-2-7><a id=__codelineno-2-7 name=__codelineno-2-7 href=#__codelineno-2-7></a>
</span><span id=__span-2-8><a id=__codelineno-2-8 name=__codelineno-2-8 href=#__codelineno-2-8></a>#define AST_FORMAT_VIDEO_MASK ((((1ULL &lt;&lt; 25)-1) &amp; ~(AST_FORMAT_AUDIO_MASK)) | 0x7FFF000000000000ULL)
</span><span id=__span-2-9><a id=__codelineno-2-9 name=__codelineno-2-9 href=#__codelineno-2-9></a>#define AST_FORMAT_H263_PLUS (1ULL &lt;&lt; 20)
</span><span id=__span-2-10><a id=__codelineno-2-10 name=__codelineno-2-10 href=#__codelineno-2-10></a>#define AST_FORMAT_MP4_VIDEO (1ULL &lt;&lt; 22)
</span></code></pre></div> <div class="language-text highlight"><pre><span></span><code><span id=__span-3-1><a id=__codelineno-3-1 name=__codelineno-3-1 href=#__codelineno-3-1></a>/*NEW */
</span><span id=__span-3-2><a id=__codelineno-3-2 name=__codelineno-3-2 href=#__codelineno-3-2></a>#define AST_FORMAT_INC 100000
</span><span id=__span-3-3><a id=__codelineno-3-3 name=__codelineno-3-3 href=#__codelineno-3-3></a>
</span><span id=__span-3-4><a id=__codelineno-3-4 name=__codelineno-3-4 href=#__codelineno-3-4></a>/* ALL FORMAT CATEGORIE */
</span><span id=__span-3-5><a id=__codelineno-3-5 name=__codelineno-3-5 href=#__codelineno-3-5></a>enum ast_format_type {
</span><span id=__span-3-6><a id=__codelineno-3-6 name=__codelineno-3-6 href=#__codelineno-3-6></a> AST_FORMAT_TYPE_AUDIO = 1 * FORMAT_INC,
</span><span id=__span-3-7><a id=__codelineno-3-7 name=__codelineno-3-7 href=#__codelineno-3-7></a> AST_FORMAT_TYPE_VIDEO = 2 * FORMAT_INC,
</span><span id=__span-3-8><a id=__codelineno-3-8 name=__codelineno-3-8 href=#__codelineno-3-8></a> AST_FORMAT_TYPE_IMAGE = 3 * FORMAT_INC,
</span><span id=__span-3-9><a id=__codelineno-3-9 name=__codelineno-3-9 href=#__codelineno-3-9></a>};
</span><span id=__span-3-10><a id=__codelineno-3-10 name=__codelineno-3-10 href=#__codelineno-3-10></a>
</span><span id=__span-3-11><a id=__codelineno-3-11 name=__codelineno-3-11 href=#__codelineno-3-11></a>enum ast_format_id {
</span><span id=__span-3-12><a id=__codelineno-3-12 name=__codelineno-3-12 href=#__codelineno-3-12></a> /* ALL AUDIO FORMAT */
</span><span id=__span-3-13><a id=__codelineno-3-13 name=__codelineno-3-13 href=#__codelineno-3-13></a> AST_FORMAT_G723_1 = 1 + AST_FORMAT_TYPE_AUDIO,
</span><span id=__span-3-14><a id=__codelineno-3-14 name=__codelineno-3-14 href=#__codelineno-3-14></a> AST_FORMAT_GSM = 2 + AST_FORMAT_TYPE_AUDIO,
</span><span id=__span-3-15><a id=__codelineno-3-15 name=__codelineno-3-15 href=#__codelineno-3-15></a> AST_FORMAT_ULAW = 3 + AST_FORMAT_TYPE_AUDIO,
</span><span id=__span-3-16><a id=__codelineno-3-16 name=__codelineno-3-16 href=#__codelineno-3-16></a> AST_FORMAT_ALAW = 4 + AST_FORMAT_TYPE_AUDIO,
</span><span id=__span-3-17><a id=__codelineno-3-17 name=__codelineno-3-17 href=#__codelineno-3-17></a>
</span><span id=__span-3-18><a id=__codelineno-3-18 name=__codelineno-3-18 href=#__codelineno-3-18></a> /* ALL VIDEO FORMAT */
</span><span id=__span-3-19><a id=__codelineno-3-19 name=__codelineno-3-19 href=#__codelineno-3-19></a> AST_FORMAT_H263_PLUS = 1 + AST_FORMAT_TYPE_VIDEO,
</span><span id=__span-3-20><a id=__codelineno-3-20 name=__codelineno-3-20 href=#__codelineno-3-20></a> AST_FORMAT_MP4_VIDEO = 2 + AST_FORMAT_TYPE_VIDEO,
</span><span id=__span-3-21><a id=__codelineno-3-21 name=__codelineno-3-21 href=#__codelineno-3-21></a>};
</span><span id=__span-3-22><a id=__codelineno-3-22 name=__codelineno-3-22 href=#__codelineno-3-22></a>
</span><span id=__span-3-23><a id=__codelineno-3-23 name=__codelineno-3-23 href=#__codelineno-3-23></a>/* Determine what category a format type is i */
</span><span id=__span-3-24><a id=__codelineno-3-24 name=__codelineno-3-24 href=#__codelineno-3-24></a>#define AST_FORMAT_GET_TYPE(format) (((unsigned int) (format-&gt;uid / AST_FORMAT_INC)) * AST_FORMAT_INC)
</span></code></pre></div></p> <h2 id=new-format-representation-code-examples-and-use-cases>New Format Representation Code Examples and Use cases.<a class=headerlink href=#new-format-representation-code-examples-and-use-cases title="Permanent link">&para;</a></h2> <p>This section shows example usage of the ast_format structure and how it replaces existing functionality in Asterisk. It also outlines other highlevel use cases that can not easilly be represented by a code example.</p> <p>Example 1: One to one mapping of old format_t usage with ast_format structure and its API.</p> <p><div class="language-text highlight"><pre><span></span><code><span id=__span-4-1><a id=__codelineno-4-1 name=__codelineno-4-1 href=#__codelineno-4-1></a> /* OLD: Media formats are represented by a bit in the format_t bit field */
</span><span id=__span-4-2><a id=__codelineno-4-2 name=__codelineno-4-2 href=#__codelineno-4-2></a> format_t read_format;
</span><span id=__span-4-3><a id=__codelineno-4-3 name=__codelineno-4-3 href=#__codelineno-4-3></a> read_format = AST_FORMAT_ULAW;
</span></code></pre></div> <div class="language-text highlight"><pre><span></span><code><span id=__span-5-1><a id=__codelineno-5-1 name=__codelineno-5-1 href=#__codelineno-5-1></a> /* NEW: Media formats are represented using the ast_format struct and are stored in an ast_cap object */
</span><span id=__span-5-2><a id=__codelineno-5-2 name=__codelineno-5-2 href=#__codelineno-5-2></a> struct ast_format read_format;
</span><span id=__span-5-3><a id=__codelineno-5-3 name=__codelineno-5-3 href=#__codelineno-5-3></a> ast_format_set(&amp;read, AST_FORMAT_ULAW);
</span></code></pre></div></p> <p>Example 2: Set an optional format attribute structure for a SILK ast_format structure capable of a dynamic sample rate.</p> <div class="language-text highlight"><pre><span></span><code><span id=__span-6-1><a id=__codelineno-6-1 name=__codelineno-6-1 href=#__codelineno-6-1></a>struct ast_format read_format;
</span><span id=__span-6-2><a id=__codelineno-6-2 name=__codelineno-6-2 href=#__codelineno-6-2></a>ast_format_set(&amp;read, AST_FORMAT_SILK,
</span><span id=__span-6-3><a id=__codelineno-6-3 name=__codelineno-6-3 href=#__codelineno-6-3></a> AST_FORMAT_SILK_RATE, 24000,
</span><span id=__span-6-4><a id=__codelineno-6-4 name=__codelineno-6-4 href=#__codelineno-6-4></a> AST_FORMAT_SILK_RATE, 16000,
</span><span id=__span-6-5><a id=__codelineno-6-5 name=__codelineno-6-5 href=#__codelineno-6-5></a> AST_FORMAT_SILK_RATE, 12000,
</span><span id=__span-6-6><a id=__codelineno-6-6 name=__codelineno-6-6 href=#__codelineno-6-6></a> AST_FORMAT_SILK_RATE, 8000,
</span><span id=__span-6-7><a id=__codelineno-6-7 name=__codelineno-6-7 href=#__codelineno-6-7></a> AST_FORMAT_END);
</span></code></pre></div> <p>Example 3: Set the sample rate of SILK ast_frame representing the sample rate of the frame's payload. Then compare the format of the ast_frame with a read format determine if translation is required.</p> <div class="language-text highlight"><pre><span></span><code><span id=__span-7-1><a id=__codelineno-7-1 name=__codelineno-7-1 href=#__codelineno-7-1></a>struct ast_format read_format;
</span><span id=__span-7-2><a id=__codelineno-7-2 name=__codelineno-7-2 href=#__codelineno-7-2></a>/* The read format is of format type SILK and can be of sample rates 8khz and 12kh */
</span><span id=__span-7-3><a id=__codelineno-7-3 name=__codelineno-7-3 href=#__codelineno-7-3></a>ast_format_set(&amp;read, AST_FORMAT_SILK,
</span><span id=__span-7-4><a id=__codelineno-7-4 name=__codelineno-7-4 href=#__codelineno-7-4></a> AST_FORMAT_SILK_RATE, 12000,
</span><span id=__span-7-5><a id=__codelineno-7-5 name=__codelineno-7-5 href=#__codelineno-7-5></a> AST_FORMAT_SILK_RATE, 8000,
</span><span id=__span-7-6><a id=__codelineno-7-6 name=__codelineno-7-6 href=#__codelineno-7-6></a> AST_FORMAT_END);
</span><span id=__span-7-7><a id=__codelineno-7-7 name=__codelineno-7-7 href=#__codelineno-7-7></a>
</span><span id=__span-7-8><a id=__codelineno-7-8 name=__codelineno-7-8 href=#__codelineno-7-8></a>/* The frame&#39;s format type is SILK and the payload is 24khz audio */
</span><span id=__span-7-9><a id=__codelineno-7-9 name=__codelineno-7-9 href=#__codelineno-7-9></a>ast_format_set(frame-&gt;subclass.format, AST_FORMAT_SILK,
</span><span id=__span-7-10><a id=__codelineno-7-10 name=__codelineno-7-10 href=#__codelineno-7-10></a> AST_FORMAT_SILK_RATE, 24000,
</span><span id=__span-7-11><a id=__codelineno-7-11 name=__codelineno-7-11 href=#__codelineno-7-11></a> AST_FORMAT_END);
</span><span id=__span-7-12><a id=__codelineno-7-12 name=__codelineno-7-12 href=#__codelineno-7-12></a>
</span><span id=__span-7-13><a id=__codelineno-7-13 name=__codelineno-7-13 href=#__codelineno-7-13></a>/* Comparing the frame with the read format shows that while the formats are identical
</span><span id=__span-7-14><a id=__codelineno-7-14 name=__codelineno-7-14 href=#__codelineno-7-14></a> * their attributes make them incompatible requiring a translation path to be built */
</span><span id=__span-7-15><a id=__codelineno-7-15 name=__codelineno-7-15 href=#__codelineno-7-15></a>if ((ast_format_cmp(&amp;read_format, frame-&gt;subclass.format) &lt; 0)) {
</span><span id=__span-7-16><a id=__codelineno-7-16 name=__codelineno-7-16 href=#__codelineno-7-16></a> /* Build Translation Path.
</span><span id=__span-7-17><a id=__codelineno-7-17 name=__codelineno-7-17 href=#__codelineno-7-17></a> * This will be the outcome of this example */
</span><span id=__span-7-18><a id=__codelineno-7-18 name=__codelineno-7-18 href=#__codelineno-7-18></a>} else {
</span><span id=__span-7-19><a id=__codelineno-7-19 name=__codelineno-7-19 href=#__codelineno-7-19></a> /* Frame&#39;s format is either identical or a subset of the read_format
</span><span id=__span-7-20><a id=__codelineno-7-20 name=__codelineno-7-20 href=#__codelineno-7-20></a> * requiring no translation path */
</span><span id=__span-7-21><a id=__codelineno-7-21 name=__codelineno-7-21 href=#__codelineno-7-21></a>}
</span></code></pre></div> <p>Example 4. Determine if a format is of type audio.</p> <p><div class="language-text highlight"><pre><span></span><code><span id=__span-8-1><a id=__codelineno-8-1 name=__codelineno-8-1 href=#__codelineno-8-1></a>/*OLD */
</span><span id=__span-8-2><a id=__codelineno-8-2 name=__codelineno-8-2 href=#__codelineno-8-2></a>format_t format = AST_FORMAT_ULAW;
</span><span id=__span-8-3><a id=__codelineno-8-3 name=__codelineno-8-3 href=#__codelineno-8-3></a>if (format &amp; AST_FORMAT_AUDO_MASK) {
</span><span id=__span-8-4><a id=__codelineno-8-4 name=__codelineno-8-4 href=#__codelineno-8-4></a> /* this is of type audi */
</span><span id=__span-8-5><a id=__codelineno-8-5 name=__codelineno-8-5 href=#__codelineno-8-5></a>}
</span></code></pre></div> <div class="language-text highlight"><pre><span></span><code><span id=__span-9-1><a id=__codelineno-9-1 name=__codelineno-9-1 href=#__codelineno-9-1></a>/*NEW */
</span><span id=__span-9-2><a id=__codelineno-9-2 name=__codelineno-9-2 href=#__codelineno-9-2></a>struct ast_format format;
</span><span id=__span-9-3><a id=__codelineno-9-3 name=__codelineno-9-3 href=#__codelineno-9-3></a>ast_format_set(&amp;format, AST_FORMAT_ULAW);
</span><span id=__span-9-4><a id=__codelineno-9-4 name=__codelineno-9-4 href=#__codelineno-9-4></a>if (AST_FORMAT_GET_TYPE(&amp;format) == AST_FORMAT_TYPE_AUDIO) {
</span><span id=__span-9-5><a id=__codelineno-9-5 name=__codelineno-9-5 href=#__codelineno-9-5></a> /* this is of type audi */
</span><span id=__span-9-6><a id=__codelineno-9-6 name=__codelineno-9-6 href=#__codelineno-9-6></a>}
</span></code></pre></div></p> <p>Example 5: Media format seamlessly changes parameters midstream.</p> <ol type=1> <li>A channel is defined to have a write format of SILK with the capabilities of understanding 8khz and 16khz without translation.</li> <li>A stream of SILK audio ast_frames containing 16khz frame attributes begin to be written to the channel.</li> <li>During the call the audio stream's SILK frame attributes change to 8khz.</li> <li>ast_write() determines this change is still within the channel's write format capabilities and continues without translation.</li> </ol> <p>Example 6: Media format changes parameters requiring translation midstream.</p> <ol type=1> <li>A channel is defined to have a write format of SILK with the capabilities of understanding 8khz and 16khz without translation.</li> <li>A stream of SILK audio ast_frames containing 16khz frame attributes begin to be written to the channel.</li> <li>During the call the audio stream's SILK frame attributes change to 24khz.</li> <li>ast_write() determines this change is not within the bounds of the channel's write format capabilities and builds a translation path from 24khz SILK to 16khz SILK.</li> </ol> <h1 id=representation-of-format-capabilities>Representation of Format Capabilities<a class=headerlink href=#representation-of-format-capabilities title="Permanent link">&para;</a></h1> <h2 id=problem-overview_1>Problem Overview<a class=headerlink href=#problem-overview_1 title="Permanent link">&para;</a></h2> <p>The new way of handling format capabilities must address two issues. First, formats are no longer represented by the format_t bit field and are replaced by the ast_format structure. This means that the old system of representing format capability sets with a bit field must be replaced as well. Second, even if we could use a bit field to represent format capability sets, the bitwise operators used to compare capabilities and calculate joint capabilities are incapable of processing the new format attribute structures. In order to handle both of these changes, an opaque capabilities container must be created to manipulate sets of ast_format structures. This container must also be coupled with an API that abstracts all the work required to compare sets of ast_formats and their internal format attributes.</p> <h2 id=introducing-ast_cap-the-format-capability-container>Introducing ast_cap, The Format Capability Container.<a class=headerlink href=#introducing-ast_cap-the-format-capability-container title="Permanent link">&para;</a></h2> <p>The Format Capability API introduces a new container type, struct ast_cap, which acts as the opaque capabilities container discussed in the overview. Like an ao2_container holds astobj2 objects, the ast_cap container holds ast_format objects. The thing that sets the ast_cap container apart from other generic containers in Asterisk is that it is designed specifically for the purpose of comparing and manipulating sets of ast_format structures. API functions for adding/removing ast_formats, computing joint capabilities, and retrieving all capabilities for a specific media type are present. The best way to communicate the big picture for how this new container and API replaces the current architecture is by providing some examples. These examples will walk through the sections discussed so far and provide a better understanding for how the ast_format and ast_cap containers interact with each other using the new API. All the examples below take code from the existing media architecture in Asterisk and show how the new architecture replaces it.</p> <p>Example 1: Add format capabilities to a peer.</p> <p><div class="language-text highlight"><pre><span></span><code><span id=__span-10-1><a id=__codelineno-10-1 name=__codelineno-10-1 href=#__codelineno-10-1></a>/* ---OLD: Media formats are represented by a bit in a bit field */
</span><span id=__span-10-2><a id=__codelineno-10-2 name=__codelineno-10-2 href=#__codelineno-10-2></a>format_t capabilities = 0;
</span><span id=__span-10-3><a id=__codelineno-10-3 name=__codelineno-10-3 href=#__codelineno-10-3></a>capabilities |= AST_FORMAT_ULAW;
</span><span id=__span-10-4><a id=__codelineno-10-4 name=__codelineno-10-4 href=#__codelineno-10-4></a>capabilities |= AST_FORMAT_GSM;
</span><span id=__span-10-5><a id=__codelineno-10-5 name=__codelineno-10-5 href=#__codelineno-10-5></a>/* XXX SILK can not be set using a bit since it requires a capability
</span><span id=__span-10-6><a id=__codelineno-10-6 name=__codelineno-10-6 href=#__codelineno-10-6></a> * attribute to be associated with it.
</span><span id=__span-10-7><a id=__codelineno-10-7 name=__codelineno-10-7 href=#__codelineno-10-7></a> * capabilities |= AST_FORMAT_SILK;
</span><span id=__span-10-8><a id=__codelineno-10-8 name=__codelineno-10-8 href=#__codelineno-10-8></a> */
</span></code></pre></div> <div class="language-text highlight"><pre><span></span><code><span id=__span-11-1><a id=__codelineno-11-1 name=__codelineno-11-1 href=#__codelineno-11-1></a>/* ---NEW: Media formats are represented using the ast_format struct and are stored in an ast_cap object. */
</span><span id=__span-11-2><a id=__codelineno-11-2 name=__codelineno-11-2 href=#__codelineno-11-2></a>struct ast_format tmp = { 0, };
</span><span id=__span-11-3><a id=__codelineno-11-3 name=__codelineno-11-3 href=#__codelineno-11-3></a>
</span><span id=__span-11-4><a id=__codelineno-11-4 name=__codelineno-11-4 href=#__codelineno-11-4></a>ast_cap_add(capabilties, ast_format_set(&amp;tmp, AST_FORMAT_ULAW));
</span><span id=__span-11-5><a id=__codelineno-11-5 name=__codelineno-11-5 href=#__codelineno-11-5></a>ast_cap_add(capabilties, ast_format_set(&amp;tmp, AST_FORMAT_GSM));
</span><span id=__span-11-6><a id=__codelineno-11-6 name=__codelineno-11-6 href=#__codelineno-11-6></a>
</span><span id=__span-11-7><a id=__codelineno-11-7 name=__codelineno-11-7 href=#__codelineno-11-7></a>/* SILK media format requires the format capability attribute to be set. */
</span><span id=__span-11-8><a id=__codelineno-11-8 name=__codelineno-11-8 href=#__codelineno-11-8></a>ast_format_set(&amp;tmp, AST_FORMAT_SILK,
</span><span id=__span-11-9><a id=__codelineno-11-9 name=__codelineno-11-9 href=#__codelineno-11-9></a> AST_FORMAT_SILK_CAP_RATE, 24000,
</span><span id=__span-11-10><a id=__codelineno-11-10 name=__codelineno-11-10 href=#__codelineno-11-10></a> AST_FORMAT_SILK_CAP_RATE, 16000,
</span><span id=__span-11-11><a id=__codelineno-11-11 name=__codelineno-11-11 href=#__codelineno-11-11></a> AST_FORMAT_SILK_CAP_RATE, 12000,
</span><span id=__span-11-12><a id=__codelineno-11-12 name=__codelineno-11-12 href=#__codelineno-11-12></a> AST_FORMAT_SILK_CAP_RATE, 8000,
</span><span id=__span-11-13><a id=__codelineno-11-13 name=__codelineno-11-13 href=#__codelineno-11-13></a> AST_FORMAT_ATTR_END);
</span><span id=__span-11-14><a id=__codelineno-11-14 name=__codelineno-11-14 href=#__codelineno-11-14></a>ast_cap_add(capabilties, &amp;tmp);
</span></code></pre></div></p> <p>Example 2: Find joint capabilities between a peer and remote endpoint.</p> <p><div class="language-text highlight"><pre><span></span><code><span id=__span-12-1><a id=__codelineno-12-1 name=__codelineno-12-1 href=#__codelineno-12-1></a>/*---OLD: Peer and remote capabilities are bit fields, no capability attributes can be used. */
</span><span id=__span-12-2><a id=__codelineno-12-2 name=__codelineno-12-2 href=#__codelineno-12-2></a>format_t jointcapabilties = 0;
</span><span id=__span-12-3><a id=__codelineno-12-3 name=__codelineno-12-3 href=#__codelineno-12-3></a>
</span><span id=__span-12-4><a id=__codelineno-12-4 name=__codelineno-12-4 href=#__codelineno-12-4></a>peer-&gt;capability |= (AST_FORMAT_ULAW | AST_FORMAT_GSM);
</span><span id=__span-12-5><a id=__codelineno-12-5 name=__codelineno-12-5 href=#__codelineno-12-5></a>
</span><span id=__span-12-6><a id=__codelineno-12-6 name=__codelineno-12-6 href=#__codelineno-12-6></a>/*
</span><span id=__span-12-7><a id=__codelineno-12-7 name=__codelineno-12-7 href=#__codelineno-12-7></a> * peer-&gt;capability = ULAW and GSM
</span><span id=__span-12-8><a id=__codelineno-12-8 name=__codelineno-12-8 href=#__codelineno-12-8></a> *
</span><span id=__span-12-9><a id=__codelineno-12-9 name=__codelineno-12-9 href=#__codelineno-12-9></a> * remote_capabilities structure is already built to contain uLaw
</span><span id=__span-12-10><a id=__codelineno-12-10 name=__codelineno-12-10 href=#__codelineno-12-10></a> * remote_capability = ULAW
</span><span id=__span-12-11><a id=__codelineno-12-11 name=__codelineno-12-11 href=#__codelineno-12-11></a> *
</span><span id=__span-12-12><a id=__codelineno-12-12 name=__codelineno-12-12 href=#__codelineno-12-12></a> * jointcapabilities will be ULAW
</span><span id=__span-12-13><a id=__codelineno-12-13 name=__codelineno-12-13 href=#__codelineno-12-13></a> */
</span><span id=__span-12-14><a id=__codelineno-12-14 name=__codelineno-12-14 href=#__codelineno-12-14></a>jointcapabilties = peer-&gt;capability &amp; remote_capability
</span></code></pre></div> <div class="language-text highlight"><pre><span></span><code><span id=__span-13-1><a id=__codelineno-13-1 name=__codelineno-13-1 href=#__codelineno-13-1></a>/*---NEW: Peer and remote capabilities are ast_cap objects. */
</span><span id=__span-13-2><a id=__codelineno-13-2 name=__codelineno-13-2 href=#__codelineno-13-2></a>struct ast_cap *jointcapabilities;
</span><span id=__span-13-3><a id=__codelineno-13-3 name=__codelineno-13-3 href=#__codelineno-13-3></a>
</span><span id=__span-13-4><a id=__codelineno-13-4 name=__codelineno-13-4 href=#__codelineno-13-4></a>ast_cap_add(peer-&gt;capability, ast_format_set(&amp;tmp, AST_FORMAT_ULAW));
</span><span id=__span-13-5><a id=__codelineno-13-5 name=__codelineno-13-5 href=#__codelineno-13-5></a>ast_cap_add(peer-&gt;capability, ast_format_set(&amp;tmp, AST_FORMAT_GSM));
</span><span id=__span-13-6><a id=__codelineno-13-6 name=__codelineno-13-6 href=#__codelineno-13-6></a>
</span><span id=__span-13-7><a id=__codelineno-13-7 name=__codelineno-13-7 href=#__codelineno-13-7></a>ast_format_set(&amp;tmp, AST_FORMAT_SILK,
</span><span id=__span-13-8><a id=__codelineno-13-8 name=__codelineno-13-8 href=#__codelineno-13-8></a> AST_FORMAT_SILK_CAP_RATE, 24000,
</span><span id=__span-13-9><a id=__codelineno-13-9 name=__codelineno-13-9 href=#__codelineno-13-9></a> AST_FORMAT_SILK_CAP_RATE, 16000,
</span><span id=__span-13-10><a id=__codelineno-13-10 name=__codelineno-13-10 href=#__codelineno-13-10></a> AST_FORMAT_SILK_CAP_RATE, 12000,
</span><span id=__span-13-11><a id=__codelineno-13-11 name=__codelineno-13-11 href=#__codelineno-13-11></a> AST_FORMAT_SILK_CAP_RATE, 8000,
</span><span id=__span-13-12><a id=__codelineno-13-12 name=__codelineno-13-12 href=#__codelineno-13-12></a> AST_FORMAT_ATTR_END);
</span><span id=__span-13-13><a id=__codelineno-13-13 name=__codelineno-13-13 href=#__codelineno-13-13></a>ast_cap_add(peer-&gt;capabilties, &amp;tmp);
</span><span id=__span-13-14><a id=__codelineno-13-14 name=__codelineno-13-14 href=#__codelineno-13-14></a>
</span><span id=__span-13-15><a id=__codelineno-13-15 name=__codelineno-13-15 href=#__codelineno-13-15></a>ast_format_set(&amp;tmp, AST_FORMAT_H264,
</span><span id=__span-13-16><a id=__codelineno-13-16 name=__codelineno-13-16 href=#__codelineno-13-16></a> AST_FORMAT_H264_CAP_PACKETIZATION, 0,
</span><span id=__span-13-17><a id=__codelineno-13-17 name=__codelineno-13-17 href=#__codelineno-13-17></a> AST_FORMAT_H264_CAP_PACKETIZATION, 1,
</span><span id=__span-13-18><a id=__codelineno-13-18 name=__codelineno-13-18 href=#__codelineno-13-18></a> AST_FORMAT_H264_CAP_RES, &quot;CIF&quot;,
</span><span id=__span-13-19><a id=__codelineno-13-19 name=__codelineno-13-19 href=#__codelineno-13-19></a> AST_FORMAT_H264_CAP_RES, &quot;VGA&quot;,
</span><span id=__span-13-20><a id=__codelineno-13-20 name=__codelineno-13-20 href=#__codelineno-13-20></a> AST_FORMAT_ATTR_END);
</span><span id=__span-13-21><a id=__codelineno-13-21 name=__codelineno-13-21 href=#__codelineno-13-21></a>ast_cap_add(peer-&gt;capabilties, &amp;tmp);
</span><span id=__span-13-22><a id=__codelineno-13-22 name=__codelineno-13-22 href=#__codelineno-13-22></a>
</span><span id=__span-13-23><a id=__codelineno-13-23 name=__codelineno-13-23 href=#__codelineno-13-23></a>/*
</span><span id=__span-13-24><a id=__codelineno-13-24 name=__codelineno-13-24 href=#__codelineno-13-24></a> * peer-&gt;capabilities structure was just built to contain.
</span><span id=__span-13-25><a id=__codelineno-13-25 name=__codelineno-13-25 href=#__codelineno-13-25></a> * silk (rate = 24000, rate = 16000, rate = 12000, rate = 8000)
</span><span id=__span-13-26><a id=__codelineno-13-26 name=__codelineno-13-26 href=#__codelineno-13-26></a> * h.264 (packetization = 0, packetization = 1, res = vga, res = cif)
</span><span id=__span-13-27><a id=__codelineno-13-27 name=__codelineno-13-27 href=#__codelineno-13-27></a> *
</span><span id=__span-13-28><a id=__codelineno-13-28 name=__codelineno-13-28 href=#__codelineno-13-28></a> * remote_capabilities structure is already built to contain
</span><span id=__span-13-29><a id=__codelineno-13-29 name=__codelineno-13-29 href=#__codelineno-13-29></a> * silk (rate = 16000)
</span><span id=__span-13-30><a id=__codelineno-13-30 name=__codelineno-13-30 href=#__codelineno-13-30></a> * h.264 (packetization = 0, res = vga, res = svga)
</span><span id=__span-13-31><a id=__codelineno-13-31 name=__codelineno-13-31 href=#__codelineno-13-31></a> *
</span><span id=__span-13-32><a id=__codelineno-13-32 name=__codelineno-13-32 href=#__codelineno-13-32></a> * The resulting jointcapabilities object contains
</span><span id=__span-13-33><a id=__codelineno-13-33 name=__codelineno-13-33 href=#__codelineno-13-33></a> * SILK (Rate = 16000khz)
</span><span id=__span-13-34><a id=__codelineno-13-34 name=__codelineno-13-34 href=#__codelineno-13-34></a> * H.264 (packetization = 0, Res = VGA)
</span><span id=__span-13-35><a id=__codelineno-13-35 name=__codelineno-13-35 href=#__codelineno-13-35></a> *
</span><span id=__span-13-36><a id=__codelineno-13-36 name=__codelineno-13-36 href=#__codelineno-13-36></a> * Computing of joint capabilities of formats with capability attributes is
</span><span id=__span-13-37><a id=__codelineno-13-37 name=__codelineno-13-37 href=#__codelineno-13-37></a> * possible because of the format attribute interface each format requiring
</span><span id=__span-13-38><a id=__codelineno-13-38 name=__codelineno-13-38 href=#__codelineno-13-38></a> * attributes must implement and register with the core.
</span><span id=__span-13-39><a id=__codelineno-13-39 name=__codelineno-13-39 href=#__codelineno-13-39></a> */
</span><span id=__span-13-40><a id=__codelineno-13-40 name=__codelineno-13-40 href=#__codelineno-13-40></a>jointcapabilities = ast_cap_joint(peer-&gt;capability, remote_capability);
</span></code></pre></div></p> <p>Example 3: Separate audio, video, and text capabilities.</p> <p><div class="language-text highlight"><pre><span></span><code><span id=__span-14-1><a id=__codelineno-14-1 name=__codelineno-14-1 href=#__codelineno-14-1></a>/*---OLD: Separate media types are separated by a bit mask. */
</span><span id=__span-14-2><a id=__codelineno-14-2 name=__codelineno-14-2 href=#__codelineno-14-2></a>format_t video_capabilities = capabilities &amp; AST_FORMAT_VIDEO_MASK;
</span><span id=__span-14-3><a id=__codelineno-14-3 name=__codelineno-14-3 href=#__codelineno-14-3></a>format_t audio_capabilities = capabilities &amp; AST_FORMAT_AUDIO_MASK;
</span><span id=__span-14-4><a id=__codelineno-14-4 name=__codelineno-14-4 href=#__codelineno-14-4></a>format_t text_capabilities = capabilities &amp; AST_FORMAT_TEXT_MASK;
</span></code></pre></div> <div class="language-text highlight"><pre><span></span><code><span id=__span-15-1><a id=__codelineno-15-1 name=__codelineno-15-1 href=#__codelineno-15-1></a>/*---NEW: Separate media types are returned on a new capabilities structure using ast_cap_get_type() */
</span><span id=__span-15-2><a id=__codelineno-15-2 name=__codelineno-15-2 href=#__codelineno-15-2></a>struct ast_cap *video = ast_cap_get_type(capabilities, AST_FORMAT_TYPE_AUDIO);
</span><span id=__span-15-3><a id=__codelineno-15-3 name=__codelineno-15-3 href=#__codelineno-15-3></a>struct ast_cap *voice = ast_cap_get_type(capabilities, AST_FORMAT_TYPE_VIDEO);
</span><span id=__span-15-4><a id=__codelineno-15-4 name=__codelineno-15-4 href=#__codelineno-15-4></a>struct ast_cap *text = ast_cap_get_type(capabilities, AST_FORMAT_TYPE_TEXT);
</span></code></pre></div></p> <h2 id=ast-format-capability-api-defined>Ast Format Capability API Defined<a class=headerlink href=#ast-format-capability-api-defined title="Permanent link">&para;</a></h2> <div class="language-text highlight"><pre><span></span><code><span id=__span-16-1><a id=__codelineno-16-1 name=__codelineno-16-1 href=#__codelineno-16-1></a>/*! Capabilities are represented by an opaque structure statically defined in format_capability. */
</span><span id=__span-16-2><a id=__codelineno-16-2 name=__codelineno-16-2 href=#__codelineno-16-2></a>struct ast_cap;
</span><span id=__span-16-3><a id=__codelineno-16-3 name=__codelineno-16-3 href=#__codelineno-16-3></a>
</span><span id=__span-16-4><a id=__codelineno-16-4 name=__codelineno-16-4 href=#__codelineno-16-4></a>/*! \brief Allocate a new ast_cap structure.
</span><span id=__span-16-5><a id=__codelineno-16-5 name=__codelineno-16-5 href=#__codelineno-16-5></a> *
</span><span id=__span-16-6><a id=__codelineno-16-6 name=__codelineno-16-6 href=#__codelineno-16-6></a> * \retval ast_cap object on success.
</span><span id=__span-16-7><a id=__codelineno-16-7 name=__codelineno-16-7 href=#__codelineno-16-7></a> * \retval NULL on failure.
</span><span id=__span-16-8><a id=__codelineno-16-8 name=__codelineno-16-8 href=#__codelineno-16-8></a> */
</span><span id=__span-16-9><a id=__codelineno-16-9 name=__codelineno-16-9 href=#__codelineno-16-9></a>struct ast_cap *ast_cap_alloc(void);
</span><span id=__span-16-10><a id=__codelineno-16-10 name=__codelineno-16-10 href=#__codelineno-16-10></a>
</span><span id=__span-16-11><a id=__codelineno-16-11 name=__codelineno-16-11 href=#__codelineno-16-11></a>/*! \brief Destroy an ast_cap structure.
</span><span id=__span-16-12><a id=__codelineno-16-12 name=__codelineno-16-12 href=#__codelineno-16-12></a> *
</span><span id=__span-16-13><a id=__codelineno-16-13 name=__codelineno-16-13 href=#__codelineno-16-13></a> * \return NULL
</span><span id=__span-16-14><a id=__codelineno-16-14 name=__codelineno-16-14 href=#__codelineno-16-14></a> */
</span><span id=__span-16-15><a id=__codelineno-16-15 name=__codelineno-16-15 href=#__codelineno-16-15></a>void *ast_cap_destroy(struct ast_cap *cap);
</span><span id=__span-16-16><a id=__codelineno-16-16 name=__codelineno-16-16 href=#__codelineno-16-16></a>
</span><span id=__span-16-17><a id=__codelineno-16-17 name=__codelineno-16-17 href=#__codelineno-16-17></a>/*! \brief Add format capability to capabilities structure.
</span><span id=__span-16-18><a id=__codelineno-16-18 name=__codelineno-16-18 href=#__codelineno-16-18></a> *
</span><span id=__span-16-19><a id=__codelineno-16-19 name=__codelineno-16-19 href=#__codelineno-16-19></a> * \note A copy of the input format is made and that copy is
</span><span id=__span-16-20><a id=__codelineno-16-20 name=__codelineno-16-20 href=#__codelineno-16-20></a> * what is placed in the ast_cap structure. The actual
</span><span id=__span-16-21><a id=__codelineno-16-21 name=__codelineno-16-21 href=#__codelineno-16-21></a> * input format ptr is not stored.
</span><span id=__span-16-22><a id=__codelineno-16-22 name=__codelineno-16-22 href=#__codelineno-16-22></a> */
</span><span id=__span-16-23><a id=__codelineno-16-23 name=__codelineno-16-23 href=#__codelineno-16-23></a>void ast_cap_add(struct ast_cap *cap, struct ast_format *format);
</span><span id=__span-16-24><a id=__codelineno-16-24 name=__codelineno-16-24 href=#__codelineno-16-24></a>
</span><span id=__span-16-25><a id=__codelineno-16-25 name=__codelineno-16-25 href=#__codelineno-16-25></a>/*! \brief Remove format capability from capability structure.
</span><span id=__span-16-26><a id=__codelineno-16-26 name=__codelineno-16-26 href=#__codelineno-16-26></a> *
</span><span id=__span-16-27><a id=__codelineno-16-27 name=__codelineno-16-27 href=#__codelineno-16-27></a> * \Note format must match Exactly to format in ast_cap object in order
</span><span id=__span-16-28><a id=__codelineno-16-28 name=__codelineno-16-28 href=#__codelineno-16-28></a> * to be removed.
</span><span id=__span-16-29><a id=__codelineno-16-29 name=__codelineno-16-29 href=#__codelineno-16-29></a> *
</span><span id=__span-16-30><a id=__codelineno-16-30 name=__codelineno-16-30 href=#__codelineno-16-30></a> * \retval 0, remove was successful
</span><span id=__span-16-31><a id=__codelineno-16-31 name=__codelineno-16-31 href=#__codelineno-16-31></a> * \retval -1, remove failed. Could not find format to remove
</span><span id=__span-16-32><a id=__codelineno-16-32 name=__codelineno-16-32 href=#__codelineno-16-32></a> */
</span><span id=__span-16-33><a id=__codelineno-16-33 name=__codelineno-16-33 href=#__codelineno-16-33></a>int ast_cap_remove(struct ast_cap *cap, struct ast_format *format);
</span><span id=__span-16-34><a id=__codelineno-16-34 name=__codelineno-16-34 href=#__codelineno-16-34></a>
</span><span id=__span-16-35><a id=__codelineno-16-35 name=__codelineno-16-35 href=#__codelineno-16-35></a>/*! \brief Remove all format capabilities from capability
</span><span id=__span-16-36><a id=__codelineno-16-36 name=__codelineno-16-36 href=#__codelineno-16-36></a> * structure for a specific format id.
</span><span id=__span-16-37><a id=__codelineno-16-37 name=__codelineno-16-37 href=#__codelineno-16-37></a> *
</span><span id=__span-16-38><a id=__codelineno-16-38 name=__codelineno-16-38 href=#__codelineno-16-38></a> * \Note This will remove _ALL_ formats matching the format id from the
</span><span id=__span-16-39><a id=__codelineno-16-39 name=__codelineno-16-39 href=#__codelineno-16-39></a> * capabilities structure.
</span><span id=__span-16-40><a id=__codelineno-16-40 name=__codelineno-16-40 href=#__codelineno-16-40></a> *
</span><span id=__span-16-41><a id=__codelineno-16-41 name=__codelineno-16-41 href=#__codelineno-16-41></a> * \retval 0, remove was successful
</span><span id=__span-16-42><a id=__codelineno-16-42 name=__codelineno-16-42 href=#__codelineno-16-42></a> * \retval -1, remove failed. Could not find formats to remove
</span><span id=__span-16-43><a id=__codelineno-16-43 name=__codelineno-16-43 href=#__codelineno-16-43></a> */
</span><span id=__span-16-44><a id=__codelineno-16-44 name=__codelineno-16-44 href=#__codelineno-16-44></a>int ast_cap_remove_byid(struct ast_cap *cap, enum ast_format_id id);
</span><span id=__span-16-45><a id=__codelineno-16-45 name=__codelineno-16-45 href=#__codelineno-16-45></a>
</span><span id=__span-16-46><a id=__codelineno-16-46 name=__codelineno-16-46 href=#__codelineno-16-46></a>/*! \brief Find if ast_format is within the capabilities of the ast_cap object.
</span><span id=__span-16-47><a id=__codelineno-16-47 name=__codelineno-16-47 href=#__codelineno-16-47></a> *
</span><span id=__span-16-48><a id=__codelineno-16-48 name=__codelineno-16-48 href=#__codelineno-16-48></a> * retval 1 format is compatible with formats held in ast_cap object.
</span><span id=__span-16-49><a id=__codelineno-16-49 name=__codelineno-16-49 href=#__codelineno-16-49></a> * retval 0 format is not compatible with any formats in ast_cap object.
</span><span id=__span-16-50><a id=__codelineno-16-50 name=__codelineno-16-50 href=#__codelineno-16-50></a> */
</span><span id=__span-16-51><a id=__codelineno-16-51 name=__codelineno-16-51 href=#__codelineno-16-51></a>int ast_cap_iscompatible(struct ast_cap *cap, struct ast_format *format);
</span><span id=__span-16-52><a id=__codelineno-16-52 name=__codelineno-16-52 href=#__codelineno-16-52></a>
</span><span id=__span-16-53><a id=__codelineno-16-53 name=__codelineno-16-53 href=#__codelineno-16-53></a>/*! \brief Get joint capability structure.
</span><span id=__span-16-54><a id=__codelineno-16-54 name=__codelineno-16-54 href=#__codelineno-16-54></a> *
</span><span id=__span-16-55><a id=__codelineno-16-55 name=__codelineno-16-55 href=#__codelineno-16-55></a> * \retval !NULL success
</span><span id=__span-16-56><a id=__codelineno-16-56 name=__codelineno-16-56 href=#__codelineno-16-56></a> * \retval NULL failure
</span><span id=__span-16-57><a id=__codelineno-16-57 name=__codelineno-16-57 href=#__codelineno-16-57></a> */
</span><span id=__span-16-58><a id=__codelineno-16-58 name=__codelineno-16-58 href=#__codelineno-16-58></a>struct ast_cap *ast_cap_joint(struct ast_cap *cap1, struct ast_cap *cap2);
</span><span id=__span-16-59><a id=__codelineno-16-59 name=__codelineno-16-59 href=#__codelineno-16-59></a>
</span><span id=__span-16-60><a id=__codelineno-16-60 name=__codelineno-16-60 href=#__codelineno-16-60></a>/*! \brief Get all capabilities for a specific media type
</span><span id=__span-16-61><a id=__codelineno-16-61 name=__codelineno-16-61 href=#__codelineno-16-61></a> *
</span><span id=__span-16-62><a id=__codelineno-16-62 name=__codelineno-16-62 href=#__codelineno-16-62></a> * \retval !NULL success
</span><span id=__span-16-63><a id=__codelineno-16-63 name=__codelineno-16-63 href=#__codelineno-16-63></a> * \retval NULL failure
</span><span id=__span-16-64><a id=__codelineno-16-64 name=__codelineno-16-64 href=#__codelineno-16-64></a> */
</span><span id=__span-16-65><a id=__codelineno-16-65 name=__codelineno-16-65 href=#__codelineno-16-65></a>struct ast_cap *ast_cap_get_type(struct ast_cap *cap, enum ast_format_type ftype);
</span><span id=__span-16-66><a id=__codelineno-16-66 name=__codelineno-16-66 href=#__codelineno-16-66></a>
</span><span id=__span-16-67><a id=__codelineno-16-67 name=__codelineno-16-67 href=#__codelineno-16-67></a>/*! \brief Start iterating format */
</span><span id=__span-16-68><a id=__codelineno-16-68 name=__codelineno-16-68 href=#__codelineno-16-68></a>void ast_cap_iter_start(struct ast_cap *cap);
</span><span id=__span-16-69><a id=__codelineno-16-69 name=__codelineno-16-69 href=#__codelineno-16-69></a>
</span><span id=__span-16-70><a id=__codelineno-16-70 name=__codelineno-16-70 href=#__codelineno-16-70></a>/*! \brief Next format in interation
</span><span id=__span-16-71><a id=__codelineno-16-71 name=__codelineno-16-71 href=#__codelineno-16-71></a> *
</span><span id=__span-16-72><a id=__codelineno-16-72 name=__codelineno-16-72 href=#__codelineno-16-72></a> * \details
</span><span id=__span-16-73><a id=__codelineno-16-73 name=__codelineno-16-73 href=#__codelineno-16-73></a> * Here is how to use the ast_cap iterator.
</span><span id=__span-16-74><a id=__codelineno-16-74 name=__codelineno-16-74 href=#__codelineno-16-74></a> *
</span><span id=__span-16-75><a id=__codelineno-16-75 name=__codelineno-16-75 href=#__codelineno-16-75></a> * 1. call ast_cap_iter_start
</span><span id=__span-16-76><a id=__codelineno-16-76 name=__codelineno-16-76 href=#__codelineno-16-76></a> * 2. call ast_cap_iter_next in a loop until it returns -1
</span><span id=__span-16-77><a id=__codelineno-16-77 name=__codelineno-16-77 href=#__codelineno-16-77></a> * 3. call ast_cap_iter_end to terminate the iterator.
</span><span id=__span-16-78><a id=__codelineno-16-78 name=__codelineno-16-78 href=#__codelineno-16-78></a> *
</span><span id=__span-16-79><a id=__codelineno-16-79 name=__codelineno-16-79 href=#__codelineno-16-79></a> * example:
</span><span id=__span-16-80><a id=__codelineno-16-80 name=__codelineno-16-80 href=#__codelineno-16-80></a> *
</span><span id=__span-16-81><a id=__codelineno-16-81 name=__codelineno-16-81 href=#__codelineno-16-81></a> * ast_cap_iter_start(cap);
</span><span id=__span-16-82><a id=__codelineno-16-82 name=__codelineno-16-82 href=#__codelineno-16-82></a> * while (!ast_cap_iter_next(cap, &amp;format)) {
</span><span id=__span-16-83><a id=__codelineno-16-83 name=__codelineno-16-83 href=#__codelineno-16-83></a> *
</span><span id=__span-16-84><a id=__codelineno-16-84 name=__codelineno-16-84 href=#__codelineno-16-84></a> * }
</span><span id=__span-16-85><a id=__codelineno-16-85 name=__codelineno-16-85 href=#__codelineno-16-85></a> * ast_cap_iter_end(Cap);
</span><span id=__span-16-86><a id=__codelineno-16-86 name=__codelineno-16-86 href=#__codelineno-16-86></a> *
</span><span id=__span-16-87><a id=__codelineno-16-87 name=__codelineno-16-87 href=#__codelineno-16-87></a> * \retval 0 on success, new format is copied into input format struct
</span><span id=__span-16-88><a id=__codelineno-16-88 name=__codelineno-16-88 href=#__codelineno-16-88></a> * \retval -1, no more formats are present.
</span><span id=__span-16-89><a id=__codelineno-16-89 name=__codelineno-16-89 href=#__codelineno-16-89></a> */
</span><span id=__span-16-90><a id=__codelineno-16-90 name=__codelineno-16-90 href=#__codelineno-16-90></a>int ast_cap_iter_next(struct ast_cap *cap, struct ast_format *format);
</span><span id=__span-16-91><a id=__codelineno-16-91 name=__codelineno-16-91 href=#__codelineno-16-91></a>
</span><span id=__span-16-92><a id=__codelineno-16-92 name=__codelineno-16-92 href=#__codelineno-16-92></a>/*! \brief Ends ast_cap iteration.
</span><span id=__span-16-93><a id=__codelineno-16-93 name=__codelineno-16-93 href=#__codelineno-16-93></a> * \note this must be call after every ast_cap_iter_start
</span><span id=__span-16-94><a id=__codelineno-16-94 name=__codelineno-16-94 href=#__codelineno-16-94></a> */
</span><span id=__span-16-95><a id=__codelineno-16-95 name=__codelineno-16-95 href=#__codelineno-16-95></a>void ast_cap_iter_end(struct ast_cap *cap);
</span><span id=__span-16-96><a id=__codelineno-16-96 name=__codelineno-16-96 href=#__codelineno-16-96></a>
</span><span id=__span-16-97><a id=__codelineno-16-97 name=__codelineno-16-97 href=#__codelineno-16-97></a>/*!
</span><span id=__span-16-98><a id=__codelineno-16-98 name=__codelineno-16-98 href=#__codelineno-16-98></a> * \brief ast_cap to iax2 bitfield format represenatation
</span><span id=__span-16-99><a id=__codelineno-16-99 name=__codelineno-16-99 href=#__codelineno-16-99></a> *
</span><span id=__span-16-100><a id=__codelineno-16-100 name=__codelineno-16-100 href=#__codelineno-16-100></a> * \note This is only to be used for IAX2 compatibility 
</span><span id=__span-16-101><a id=__codelineno-16-101 name=__codelineno-16-101 href=#__codelineno-16-101></a> *
</span><span id=__span-16-102><a id=__codelineno-16-102 name=__codelineno-16-102 href=#__codelineno-16-102></a> * \retval iax2 representation of ast_cap
</span><span id=__span-16-103><a id=__codelineno-16-103 name=__codelineno-16-103 href=#__codelineno-16-103></a> * \retval 0, if no iax2 capabilities are present in ast_cap
</span><span id=__span-16-104><a id=__codelineno-16-104 name=__codelineno-16-104 href=#__codelineno-16-104></a> */
</span><span id=__span-16-105><a id=__codelineno-16-105 name=__codelineno-16-105 href=#__codelineno-16-105></a>uint64_t ast_cap_to_iax2(struct ast_cap *cap);
</span><span id=__span-16-106><a id=__codelineno-16-106 name=__codelineno-16-106 href=#__codelineno-16-106></a>
</span><span id=__span-16-107><a id=__codelineno-16-107 name=__codelineno-16-107 href=#__codelineno-16-107></a>/*!
</span><span id=__span-16-108><a id=__codelineno-16-108 name=__codelineno-16-108 href=#__codelineno-16-108></a> * \brief convert iax2 bitfield format to ast_cap represenatation
</span><span id=__span-16-109><a id=__codelineno-16-109 name=__codelineno-16-109 href=#__codelineno-16-109></a> * \note This is only to be used for IAX2 compatibility 
</span><span id=__span-16-110><a id=__codelineno-16-110 name=__codelineno-16-110 href=#__codelineno-16-110></a> */
</span><span id=__span-16-111><a id=__codelineno-16-111 name=__codelineno-16-111 href=#__codelineno-16-111></a>void ast_cap_from_iax2(uint64_t src, struct ast_cap *dst);
</span></code></pre></div> <h1 id=iax2-ast-format-api-compatibility>IAX2 Ast Format API Compatibility<a class=headerlink href=#iax2-ast-format-api-compatibility title="Permanent link">&para;</a></h1> <p>IAX2 represents media formats the same way Asterisk currently does using a bit field. This allows Asterisk to communicate format capabilities over IAX2 using the exact same representation Asterisk uses internally. This relationship between Asterisk and IAX2 breaks with the introduction of the ast_format and ast_cap structures though. In order for Asterisk to maintain compatiblity with IAX2 a conversion layer must exist between the previous format representation and the new format representation. This conversion layer will be limited to the formats defined at the moment the media format representation in Asterisk changes to use the ast_format structure. As new media formats are introduced, they must be added to this conversion layer in order to be transported over IAX2. Any media formats requiring the use of media attributes may have to be excluded from this conversion depending on their complexity. Eventually the number of media formats that can be represented in IAX2 will be exhasted. At that point it must be decided to either accept that limitation or alter the protocol in a way that will expand it to take advantage of Asterisk's new format capabilities. This proposal is not defining a change any changes to the IAX2 protocol.</p> <h1 id=revised-format-translation>Revised Format Translation<a class=headerlink href=#revised-format-translation title="Permanent link">&para;</a></h1> <h2 id=problem-overview_2>Problem Overview<a class=headerlink href=#problem-overview_2 title="Permanent link">&para;</a></h2> <p>There are two sets of problems that must be addressed in regards to media translation in Asterisk. The first set of problems is a ripple effect caused by the changes surrounding the new representation of media formats with attributes. Translators must gain the ability to process these attributes and build translation paths between formats requiring the use of them. The other set of problems involves the ability to translate between media types other than just audio. The current translation architecture is very audio specific. It assumes that all translators are audio format translators of some kind, and that no other media type will ever be translated. This assumption is not only within the translation code, it is also deeply rooted throughout the code base. The ability to translate between media other than audio is a concept Asterisk completely lacks at the moment.</p> <p>This section builds upon the foundation established by the new ast_format media format representation and uses it to redefine what translators look like and how translation paths are built. After these changes are made Asterisk will still not be able to translate video or other types of media even if translation paths actually exist between them. This problem is a result of limitations set in place by the Ast Channel API. The changes required to lift that limitation are discussed in the "Handling Multiple Media Streams" section.</p> <h2 id=building-translation-paths>Building Translation Paths<a class=headerlink href=#building-translation-paths title="Permanent link">&para;</a></h2> <p>The current method of calculating translation cost by using the computational time required to translate between formats is no longer effective. When all the formats in Asterisk were 8khz audio, picking the best translation path based upon computational cost made sense. The problem with this system now is that it does not take into account the quality of the translation. It may be computationally quicker to translated from one 16khz audio format to another 16khz audio format using 8khz signed linear audio even when 16khz signed linear is an option. Regardless of the computational costs, down sampling an audio stream unless it is absolutely necessary is a bad idea from a quality perspective. Provisions were made in the current code base to account for the down sampling issue just described, but the introduction of that fix was merely a hack to sustain the current system until a more robust architecture could be set in place. The new system must be aware of quality changes between all forms of media, not just sample rate.</p> <p>Instead of building a translation cost table out based on computational complexity, the table should be built based on what kind of translation is taking place. For example categorizing a translator as a "lossless to lossy translation with a down sampling of quality" gives quite a bit more information about what kind of translation is actually taking place than simply knowing the translation is between two formats and it takes x amount of time to compute 1 second of sample data. As new formats are introduced, knowing how all the different translators affect media during translation allows the path builder algorithm to consistently produce the best quality available.</p> <h3 id=computing-translation-costs>Computing Translation Costs<a class=headerlink href=#computing-translation-costs title="Permanent link">&para;</a></h3> <p>The new translation cost table is built on a scale between 400 and 9999. Notice that the lowest cost is 400 and the next cost after that is 600. These two numbers add up to 1000, which guarantees that a direct translation path will always take precedence over any path containing multiple translation steps. The only exception to this rule is a multiple step translation path between lossless formats of the same quality, which does not exist in Asterisk yet but may in the future.</p> <p>Every one of these cost categories can be thought of as a range starting at the number listed and ranging all the way up to the next category. If a format is capable of multiple translators for any single category listed below, the cost associated with those translators should not fall onto the same cost number as each other. Instead each translator for a single format calling into the same cost table category should be given a weighted cost within the category's range. For example, siren17 is a 32khz audio codec with translators capable of down sampling to both 16khz signed linear and 8khz signed linear. Both of these translators fall under the [~dvossel@digium.com:lossy -&gt; lossless] downsample" category which starts at cost 960. In order to make this work the 16khz conversion would be 960 and the 8khz conversion would be 961. This gives the translator that loses the least amount of information priority over the the one that loses more if a tie occurs.</p> <p>This cost table is weighted in a way that assigns lower cost to translators with the most ideal outcome. For example, translating between a lossless format to a lossy format is aways more ideal that converting a lossy format to a lossless format, translating between two lossy formats of the same quality is always more ideal than translating to a lossy format of lesser quality, and translating to a format of equivalent in quality to the original format is more ideal than any translation that requires some sort of re-sampling. The costs are computed based on these principles and more.</p> <h3 id=translation-cost-table>Translation Cost Table<a class=headerlink href=#translation-cost-table title="Permanent link">&para;</a></h3> <p>Table Terms *Up Sample:* The original format is translated to a format capable of representing more detailed information than the original one. Examples of this term would be audio codec being translated to a higher sample rate, a video codec being translated to a higher resolution/frame rate, or an image being translated to a higher resolution.</p> <p>*Down Sample:* The original format is translated to a format of lesser quality. Examples of this term would be audio codec being translated to a lower sample rate, a video codec being translated to a lower resolution/frame rate, or an image being translated to a lower resolution.</p> <p>*Original Sampling:* The original format is translated to a format of similar quality with little to no loss of information. Examples of this term would be an audio codec being translated to a format equivalent in quality of the original one, a video codec being translated to a format which preserves all the original information present, and an image being translated to another format preserving the same resolution and color depth.</p> <div class="language-text highlight"><pre><span></span><code><span id=__span-17-1><a id=__codelineno-17-1 name=__codelineno-17-1 href=#__codelineno-17-1></a>--- Lossless Source Translation Costs
</span><span id=__span-17-2><a id=__codelineno-17-2 name=__codelineno-17-2 href=#__codelineno-17-2></a>400 [lossless -&gt; lossless] original sampling
</span><span id=__span-17-3><a id=__codelineno-17-3 name=__codelineno-17-3 href=#__codelineno-17-3></a>600 [lossless -&gt; lossy] original sampling
</span><span id=__span-17-4><a id=__codelineno-17-4 name=__codelineno-17-4 href=#__codelineno-17-4></a>800 [lossless -&gt; lossless] up sample
</span><span id=__span-17-5><a id=__codelineno-17-5 name=__codelineno-17-5 href=#__codelineno-17-5></a>825 [lossless -&gt; lossy] up sample
</span><span id=__span-17-6><a id=__codelineno-17-6 name=__codelineno-17-6 href=#__codelineno-17-6></a>850 [lossless -&gt; lossless] down sample
</span><span id=__span-17-7><a id=__codelineno-17-7 name=__codelineno-17-7 href=#__codelineno-17-7></a>875 [lossless -&gt; lossy] down sample
</span><span id=__span-17-8><a id=__codelineno-17-8 name=__codelineno-17-8 href=#__codelineno-17-8></a>885 [lossless -&gt; Unknown] Unknown sample
</span><span id=__span-17-9><a id=__codelineno-17-9 name=__codelineno-17-9 href=#__codelineno-17-9></a>
</span><span id=__span-17-10><a id=__codelineno-17-10 name=__codelineno-17-10 href=#__codelineno-17-10></a>--- Lossy Source Translation Costs
</span><span id=__span-17-11><a id=__codelineno-17-11 name=__codelineno-17-11 href=#__codelineno-17-11></a>900 [lossy -&gt; lossless] original sampling
</span><span id=__span-17-12><a id=__codelineno-17-12 name=__codelineno-17-12 href=#__codelineno-17-12></a>915 [lossy -&gt; lossy] original sampling
</span><span id=__span-17-13><a id=__codelineno-17-13 name=__codelineno-17-13 href=#__codelineno-17-13></a>930 [lossy -&gt; lossless] up sample
</span><span id=__span-17-14><a id=__codelineno-17-14 name=__codelineno-17-14 href=#__codelineno-17-14></a>945 [lossy -&gt; lossy] up sample
</span><span id=__span-17-15><a id=__codelineno-17-15 name=__codelineno-17-15 href=#__codelineno-17-15></a>960 [lossy -&gt; lossless] down sample
</span><span id=__span-17-16><a id=__codelineno-17-16 name=__codelineno-17-16 href=#__codelineno-17-16></a>975 [lossy -&gt; lossy] down sample
</span><span id=__span-17-17><a id=__codelineno-17-17 name=__codelineno-17-17 href=#__codelineno-17-17></a>985 [lossy -&gt; Unknown] Unknown sample
</span></code></pre></div> <h3 id=translation-path-examples>Translation Path Examples<a class=headerlink href=#translation-path-examples title="Permanent link">&para;</a></h3> <p>*Example 1:* Downsampling g722 to ulaw using signed linear as an intermediary step. Notice that using two lossless conversions is more expensive than downsampling g722 directly to 8khz slin.</p> <div class="language-text highlight"><pre><span></span><code><span id=__span-18-1><a id=__codelineno-18-1 name=__codelineno-18-1 href=#__codelineno-18-1></a>[g722-&gt;slin16-&gt;slin-&gt;ulaw] 900+850+600 = 2350
</span><span id=__span-18-2><a id=__codelineno-18-2 name=__codelineno-18-2 href=#__codelineno-18-2></a>[g722-&gt;slin-&gt;ulaw] 960+600 = 1560 wins
</span></code></pre></div> <p>*Example 2:* Direct lossy to loss translation using ulaw to alaw. Notice how the direct path between uLaw and aLaw beats using the intermediary slin step.</p> <div class="language-text highlight"><pre><span></span><code><span id=__span-19-1><a id=__codelineno-19-1 name=__codelineno-19-1 href=#__codelineno-19-1></a>[ulaw-&gt;slin-&gt;alaw] 900+600 = 1500
</span><span id=__span-19-2><a id=__codelineno-19-2 name=__codelineno-19-2 href=#__codelineno-19-2></a>[ulaw-&gt;alaw] 945 = 945 wins
</span></code></pre></div> <p>*Example 3:* Complex resampling of siren14 to siren7 using g722 as an intermediary step. Notice how downsamping all the way to 8khz signed linear loses to the path that only requires downsampling to 16khz signed linear.</p> <div class="language-text highlight"><pre><span></span><code><span id=__span-20-1><a id=__codelineno-20-1 name=__codelineno-20-1 href=#__codelineno-20-1></a>[siren14-&gt;slin-&gt;g722-&gt;slin16-&gt;siren7] 960+825+900+600 = 3285
</span><span id=__span-20-2><a id=__codelineno-20-2 name=__codelineno-20-2 href=#__codelineno-20-2></a>[siren14-&gt;slin16-&gt;g722-&gt;slin16-&gt;siren7] 960+600+900+600 = 3060 wins
</span></code></pre></div> <p>*Example 4:* Complex resampling using siren14 to a fake 32khz lossy codec. Notice how siren14-&gt;slin16 has a 830 cost while siren14-slin8 has 831. This allows translations within the same category to be weighted against each other to produce the best quality.</p> <div class="language-text highlight"><pre><span></span><code><span id=__span-21-1><a id=__codelineno-21-1 name=__codelineno-21-1 href=#__codelineno-21-1></a>[siren14-&gt;slin-&gt;Fake 32khz lossy Codec] 961+825 = 1786
</span><span id=__span-21-2><a id=__codelineno-21-2 name=__codelineno-21-2 href=#__codelineno-21-2></a>[siren14-&gt;slin16-&gt;Fake 32khz lossy Codec] 960+825 = 1785 wins
</span></code></pre></div> <h3 id=translator-costs-defined>Translator Costs Defined.<a class=headerlink href=#translator-costs-defined title="Permanent link">&para;</a></h3> <p>Note that the table costs actually defined in the code are larger than the ones discussed so far by a factor of 1000.</p> <div class="language-text highlight"><pre><span></span><code><span id=__span-22-1><a id=__codelineno-22-1 name=__codelineno-22-1 href=#__codelineno-22-1></a>/*!
</span><span id=__span-22-2><a id=__codelineno-22-2 name=__codelineno-22-2 href=#__codelineno-22-2></a> * \brief Translator Cost Table definition.
</span><span id=__span-22-3><a id=__codelineno-22-3 name=__codelineno-22-3 href=#__codelineno-22-3></a> *
</span><span id=__span-22-4><a id=__codelineno-22-4 name=__codelineno-22-4 href=#__codelineno-22-4></a> * \note The defined values in this table must be used to set
</span><span id=__span-22-5><a id=__codelineno-22-5 name=__codelineno-22-5 href=#__codelineno-22-5></a> * the translator&#39;s table_cost value.
</span><span id=__span-22-6><a id=__codelineno-22-6 name=__codelineno-22-6 href=#__codelineno-22-6></a> *
</span><span id=__span-22-7><a id=__codelineno-22-7 name=__codelineno-22-7 href=#__codelineno-22-7></a> * \note The cost value of the first two values must always add
</span><span id=__span-22-8><a id=__codelineno-22-8 name=__codelineno-22-8 href=#__codelineno-22-8></a> * up to be greater than the largest value defined in this table.
</span><span id=__span-22-9><a id=__codelineno-22-9 name=__codelineno-22-9 href=#__codelineno-22-9></a> * This is done to guarantee a direct translation will always
</span><span id=__span-22-10><a id=__codelineno-22-10 name=__codelineno-22-10 href=#__codelineno-22-10></a> * have precedence over a multi step translation.
</span><span id=__span-22-11><a id=__codelineno-22-11 name=__codelineno-22-11 href=#__codelineno-22-11></a> *
</span><span id=__span-22-12><a id=__codelineno-22-12 name=__codelineno-22-12 href=#__codelineno-22-12></a> * \details This table is built in a way that allows translation
</span><span id=__span-22-13><a id=__codelineno-22-13 name=__codelineno-22-13 href=#__codelineno-22-13></a> * paths to be built that guarantee the best possible balance
</span><span id=__span-22-14><a id=__codelineno-22-14 name=__codelineno-22-14 href=#__codelineno-22-14></a> * between performance and quality. With this table direct
</span><span id=__span-22-15><a id=__codelineno-22-15 name=__codelineno-22-15 href=#__codelineno-22-15></a> * translation paths between two formats always takes precedence
</span><span id=__span-22-16><a id=__codelineno-22-16 name=__codelineno-22-16 href=#__codelineno-22-16></a> * over multi step paths, lossless intermediate steps are always
</span><span id=__span-22-17><a id=__codelineno-22-17 name=__codelineno-22-17 href=#__codelineno-22-17></a> * chosen over lossy intermediate steps, and preservation of
</span><span id=__span-22-18><a id=__codelineno-22-18 name=__codelineno-22-18 href=#__codelineno-22-18></a> * sample rate across the translation will always have precedence
</span><span id=__span-22-19><a id=__codelineno-22-19 name=__codelineno-22-19 href=#__codelineno-22-19></a> * over a path that involves any re-sampling.
</span><span id=__span-22-20><a id=__codelineno-22-20 name=__codelineno-22-20 href=#__codelineno-22-20></a> */
</span><span id=__span-22-21><a id=__codelineno-22-21 name=__codelineno-22-21 href=#__codelineno-22-21></a>enum ast_trans_cost_table {
</span><span id=__span-22-22><a id=__codelineno-22-22 name=__codelineno-22-22 href=#__codelineno-22-22></a>
</span><span id=__span-22-23><a id=__codelineno-22-23 name=__codelineno-22-23 href=#__codelineno-22-23></a> /* Lossless Source Translation Cost */
</span><span id=__span-22-24><a id=__codelineno-22-24 name=__codelineno-22-24 href=#__codelineno-22-24></a>
</span><span id=__span-22-25><a id=__codelineno-22-25 name=__codelineno-22-25 href=#__codelineno-22-25></a> /*! [lossless -&gt; lossless] original samplin */
</span><span id=__span-22-26><a id=__codelineno-22-26 name=__codelineno-22-26 href=#__codelineno-22-26></a> AST_TRANS_COST_LL_LL_ORIGSAMP = 400000,
</span><span id=__span-22-27><a id=__codelineno-22-27 name=__codelineno-22-27 href=#__codelineno-22-27></a> /*! [lossless -&gt; lossy] original samplin */
</span><span id=__span-22-28><a id=__codelineno-22-28 name=__codelineno-22-28 href=#__codelineno-22-28></a> AST_TRANS_COST_LL_LY_ORIGSAMP = 600000,
</span><span id=__span-22-29><a id=__codelineno-22-29 name=__codelineno-22-29 href=#__codelineno-22-29></a>
</span><span id=__span-22-30><a id=__codelineno-22-30 name=__codelineno-22-30 href=#__codelineno-22-30></a> /*! [lossless -&gt; lossless] up sampl */
</span><span id=__span-22-31><a id=__codelineno-22-31 name=__codelineno-22-31 href=#__codelineno-22-31></a> AST_TRANS_COST_LL_LL_UPSAMP = 800000,
</span><span id=__span-22-32><a id=__codelineno-22-32 name=__codelineno-22-32 href=#__codelineno-22-32></a> /*! [lossless -&gt; lossy] up sampl */
</span><span id=__span-22-33><a id=__codelineno-22-33 name=__codelineno-22-33 href=#__codelineno-22-33></a> AST_TRANS_COST_LL_LY_UPSAMP = 825000,
</span><span id=__span-22-34><a id=__codelineno-22-34 name=__codelineno-22-34 href=#__codelineno-22-34></a>
</span><span id=__span-22-35><a id=__codelineno-22-35 name=__codelineno-22-35 href=#__codelineno-22-35></a> /*! [lossless -&gt; lossless] down sampl */
</span><span id=__span-22-36><a id=__codelineno-22-36 name=__codelineno-22-36 href=#__codelineno-22-36></a> AST_TRANS_COST_LL_LL_DOWNSAMP = 850000,
</span><span id=__span-22-37><a id=__codelineno-22-37 name=__codelineno-22-37 href=#__codelineno-22-37></a> /*! [lossless -&gt; lossy] down sampl */
</span><span id=__span-22-38><a id=__codelineno-22-38 name=__codelineno-22-38 href=#__codelineno-22-38></a> AST_TRANS_COST_LL_LY_DOWNSAMP = 875000,
</span><span id=__span-22-39><a id=__codelineno-22-39 name=__codelineno-22-39 href=#__codelineno-22-39></a>
</span><span id=__span-22-40><a id=__codelineno-22-40 name=__codelineno-22-40 href=#__codelineno-22-40></a> /*! [lossless -&gt; unknown] unknown.
</span><span id=__span-22-41><a id=__codelineno-22-41 name=__codelineno-22-41 href=#__codelineno-22-41></a> * This value is for a lossless source translation
</span><span id=__span-22-42><a id=__codelineno-22-42 name=__codelineno-22-42 href=#__codelineno-22-42></a> * with an unknown destination and or sample rate conversion */
</span><span id=__span-22-43><a id=__codelineno-22-43 name=__codelineno-22-43 href=#__codelineno-22-43></a> AST_TRANS_COST_LL_UNKNOWN = 885000,
</span><span id=__span-22-44><a id=__codelineno-22-44 name=__codelineno-22-44 href=#__codelineno-22-44></a>
</span><span id=__span-22-45><a id=__codelineno-22-45 name=__codelineno-22-45 href=#__codelineno-22-45></a> /* Lossy Source Translation Cost */
</span><span id=__span-22-46><a id=__codelineno-22-46 name=__codelineno-22-46 href=#__codelineno-22-46></a>
</span><span id=__span-22-47><a id=__codelineno-22-47 name=__codelineno-22-47 href=#__codelineno-22-47></a> /*! [lossy -&gt; lossless] original samplin */
</span><span id=__span-22-48><a id=__codelineno-22-48 name=__codelineno-22-48 href=#__codelineno-22-48></a> AST_TRANS_COST_LY_LL_ORIGSAMP = 900000,
</span><span id=__span-22-49><a id=__codelineno-22-49 name=__codelineno-22-49 href=#__codelineno-22-49></a> /*! [lossy -&gt; lossy] original samplin */
</span><span id=__span-22-50><a id=__codelineno-22-50 name=__codelineno-22-50 href=#__codelineno-22-50></a> AST_TRANS_COST_LY_LY_ORIGSAMP = 915000,
</span><span id=__span-22-51><a id=__codelineno-22-51 name=__codelineno-22-51 href=#__codelineno-22-51></a>
</span><span id=__span-22-52><a id=__codelineno-22-52 name=__codelineno-22-52 href=#__codelineno-22-52></a> /*! [lossy -&gt; lossless] up sampl */
</span><span id=__span-22-53><a id=__codelineno-22-53 name=__codelineno-22-53 href=#__codelineno-22-53></a> AST_TRANS_COST_LY_LL_UPSAMP = 930000,
</span><span id=__span-22-54><a id=__codelineno-22-54 name=__codelineno-22-54 href=#__codelineno-22-54></a> /*! [lossy -&gt; lossy] up sampl */
</span><span id=__span-22-55><a id=__codelineno-22-55 name=__codelineno-22-55 href=#__codelineno-22-55></a> AST_TRANS_COST_LY_LY_UPSAMP = 945000,
</span><span id=__span-22-56><a id=__codelineno-22-56 name=__codelineno-22-56 href=#__codelineno-22-56></a>
</span><span id=__span-22-57><a id=__codelineno-22-57 name=__codelineno-22-57 href=#__codelineno-22-57></a> /*! [lossy -&gt; lossless] down sampl */
</span><span id=__span-22-58><a id=__codelineno-22-58 name=__codelineno-22-58 href=#__codelineno-22-58></a> AST_TRANS_COST_LY_LL_DOWNSAMP = 960000,
</span><span id=__span-22-59><a id=__codelineno-22-59 name=__codelineno-22-59 href=#__codelineno-22-59></a> /*! [lossy -&gt; lossy] down sampl */
</span><span id=__span-22-60><a id=__codelineno-22-60 name=__codelineno-22-60 href=#__codelineno-22-60></a> AST_TRANS_COST_LY_LY_DOWNSAMP = 975000,
</span><span id=__span-22-61><a id=__codelineno-22-61 name=__codelineno-22-61 href=#__codelineno-22-61></a>
</span><span id=__span-22-62><a id=__codelineno-22-62 name=__codelineno-22-62 href=#__codelineno-22-62></a> /*! [lossy -&gt; unknown] unknown.
</span><span id=__span-22-63><a id=__codelineno-22-63 name=__codelineno-22-63 href=#__codelineno-22-63></a> * This value is for a lossy source translation
</span><span id=__span-22-64><a id=__codelineno-22-64 name=__codelineno-22-64 href=#__codelineno-22-64></a> * with an unknown destination and or sample rate conversion */
</span><span id=__span-22-65><a id=__codelineno-22-65 name=__codelineno-22-65 href=#__codelineno-22-65></a> AST_TRANS_COST_LY_UNKNOWN = 985000,
</span><span id=__span-22-66><a id=__codelineno-22-66 name=__codelineno-22-66 href=#__codelineno-22-66></a>
</span><span id=__span-22-67><a id=__codelineno-22-67 name=__codelineno-22-67 href=#__codelineno-22-67></a>};
</span></code></pre></div> <h3 id=creation-of-translation-path-matrix>Creation of Translation Path Matrix<a class=headerlink href=#creation-of-translation-path-matrix title="Permanent link">&para;</a></h3> <p>Most least cost algorithms take a matrix as input. The current code's translation path matrix is represented by a 2 dimensional array of translation path structures. The current matrix will not change structurally, but there are some complications involved. The current code accesses translation paths from the matrix using index values which represent individual formats. The index values are computed by converting the format's bit representation to a numeric value. Since the numeric representation of a format bit has to be between 1 and 64, the maximum size of the bit field in use, the numeric representation works as an index for the current two dimensional matrix. With the introduction of the ast_format structure, this conversion between a format's unique id and the a matrix index value is not clean. To account for this complication a hash table mapping every format id to a matrix index value will be used.</p> <h3 id=computing-least-cost-translation-paths>Computing Least Cost Translation Paths<a class=headerlink href=#computing-least-cost-translation-paths title="Permanent link">&para;</a></h3> <p>The Floyd-Warshall algorithm will be the least cost algorithm in use. At its core, the current translation path building code uses this algorithm but has a few layers of complexity added on top of the base algorithm to deal with translation paths between audio codecs of differing sample rates. With the introduction of the new translation cost table, this additional complexity is completely stripped away from the algorithm. Now the translation costs are computed with translation quality and efficiency in mind, which abstracts these concepts away from least cost algorithm in use.</p> <div class="language-text highlight"><pre><span></span><code><span id=__span-23-1><a id=__codelineno-23-1 name=__codelineno-23-1 href=#__codelineno-23-1></a>FloydWarshall ()
</span><span id=__span-23-2><a id=__codelineno-23-2 name=__codelineno-23-2 href=#__codelineno-23-2></a> for k := 1 to n
</span><span id=__span-23-3><a id=__codelineno-23-3 name=__codelineno-23-3 href=#__codelineno-23-3></a> for i := 1 to n
</span><span id=__span-23-4><a id=__codelineno-23-4 name=__codelineno-23-4 href=#__codelineno-23-4></a> for j := 1 to n
</span><span id=__span-23-5><a id=__codelineno-23-5 name=__codelineno-23-5 href=#__codelineno-23-5></a> path[i][j] = min (path[i][j], path[i][k]+path[k][j]);
</span></code></pre></div> <h2 id=translator-redundancy-and-failover>Translator Redundancy and Failover<a class=headerlink href=#translator-redundancy-and-failover title="Permanent link">&para;</a></h2> <p>It is possible that multiple redundant translators may exist for a single translation path. A common example of this would be a hardware translator with limited capacity coupled with a software translator. Both of these translators perform the exact same task, but the hardware translator is much faster. In this case the hardware translator would be used until it reached capacity and then it would failover to the software translator. There is however a complication involved with this. Only one of these translators can exist in the translation path matrix at a time. This means that when multiple translators with the same source and destination formats are present, some sort of priority must be used to pick which one is used. If the translator in use reaches capacity it then must deactivate itself allowing the matrix to be rebuilt in order to take advantage of the redundant translator.</p> <p>In order to prioritize redundant translators, computational cost will be used. Formats requiring the use of redundant translators must supply a set of sample data to translate. This data is already present for most audio formats because it is required by the current architecture to compute translation cost. Translation cost in the new architecture is replaced by the translation cost table, but computational cost is still important when choosing between redundant translators.</p> <h2 id=redefining-the-translator-interface>Redefining The Translator Interface<a class=headerlink href=#redefining-the-translator-interface title="Permanent link">&para;</a></h2> <p>Translators are currently defined by a simple set of functions (constructor, destructor, framein, frameout) coupled with a source and destination media format to translate between. There is not much that needs to be changed about this interface except that the source and destination formats must be converted to be ast_format structures in all the existing code, and each translator must provide a cost value. There will be a table available to guide exactly what cost value to use. In order to make any future changes to the cost table effortless, defined values will be used when assigning cost to a translator. Otherwise this interface is in great shape for the changes ahead.</p> <div class="language-text highlight"><pre><span></span><code><span id=__span-24-1><a id=__codelineno-24-1 name=__codelineno-24-1 href=#__codelineno-24-1></a>/* each format must be declared statically no */
</span><span id=__span-24-2><a id=__codelineno-24-2 name=__codelineno-24-2 href=#__codelineno-24-2></a>static struct ast_format slin16;
</span><span id=__span-24-3><a id=__codelineno-24-3 name=__codelineno-24-3 href=#__codelineno-24-3></a>static struct ast_format g722;
</span><span id=__span-24-4><a id=__codelineno-24-4 name=__codelineno-24-4 href=#__codelineno-24-4></a>
</span><span id=__span-24-5><a id=__codelineno-24-5 name=__codelineno-24-5 href=#__codelineno-24-5></a>/* each interface holds a pointer to the static formats */
</span><span id=__span-24-6><a id=__codelineno-24-6 name=__codelineno-24-6 href=#__codelineno-24-6></a>static struct ast_translator lin16tog722 = {
</span><span id=__span-24-7><a id=__codelineno-24-7 name=__codelineno-24-7 href=#__codelineno-24-7></a> .name = &quot;lin16tog722&quot;,
</span><span id=__span-24-8><a id=__codelineno-24-8 name=__codelineno-24-8 href=#__codelineno-24-8></a> .cost = AST_TRANS_COST_LL_LY_ORIGSAMP,
</span><span id=__span-24-9><a id=__codelineno-24-9 name=__codelineno-24-9 href=#__codelineno-24-9></a> .srcfmt = &amp;slin16,
</span><span id=__span-24-10><a id=__codelineno-24-10 name=__codelineno-24-10 href=#__codelineno-24-10></a> .dstfmt = &amp;g722,
</span><span id=__span-24-11><a id=__codelineno-24-11 name=__codelineno-24-11 href=#__codelineno-24-11></a> .newpvt = lin16tog722_new, /* same for both direction */
</span><span id=__span-24-12><a id=__codelineno-24-12 name=__codelineno-24-12 href=#__codelineno-24-12></a> .framein = lintog722_framein,
</span><span id=__span-24-13><a id=__codelineno-24-13 name=__codelineno-24-13 href=#__codelineno-24-13></a> .sample = slin16_sample,
</span><span id=__span-24-14><a id=__codelineno-24-14 name=__codelineno-24-14 href=#__codelineno-24-14></a> .desc_size = sizeof(struct g722_encoder_pvt),
</span><span id=__span-24-15><a id=__codelineno-24-15 name=__codelineno-24-15 href=#__codelineno-24-15></a> .buffer_samples = BUFFER_SAMPLES * 2,
</span><span id=__span-24-16><a id=__codelineno-24-16 name=__codelineno-24-16 href=#__codelineno-24-16></a> .buf_size = BUFFER_SAMPLES,
</span><span id=__span-24-17><a id=__codelineno-24-17 name=__codelineno-24-17 href=#__codelineno-24-17></a>};
</span><span id=__span-24-18><a id=__codelineno-24-18 name=__codelineno-24-18 href=#__codelineno-24-18></a>
</span><span id=__span-24-19><a id=__codelineno-24-19 name=__codelineno-24-19 href=#__codelineno-24-19></a>/* Notice the static formats are initialized before registering the translato */
</span><span id=__span-24-20><a id=__codelineno-24-20 name=__codelineno-24-20 href=#__codelineno-24-20></a>static int load_module(void)
</span><span id=__span-24-21><a id=__codelineno-24-21 name=__codelineno-24-21 href=#__codelineno-24-21></a>{
</span><span id=__span-24-22><a id=__codelineno-24-22 name=__codelineno-24-22 href=#__codelineno-24-22></a> int res = 0;
</span><span id=__span-24-23><a id=__codelineno-24-23 name=__codelineno-24-23 href=#__codelineno-24-23></a>
</span><span id=__span-24-24><a id=__codelineno-24-24 name=__codelineno-24-24 href=#__codelineno-24-24></a> ast_format_set(&amp;slin16, AST_FORMAT_SLIN16);
</span><span id=__span-24-25><a id=__codelineno-24-25 name=__codelineno-24-25 href=#__codelineno-24-25></a> ast_format_set(&amp;g722, AST_FORMAT_G722);
</span><span id=__span-24-26><a id=__codelineno-24-26 name=__codelineno-24-26 href=#__codelineno-24-26></a>
</span><span id=__span-24-27><a id=__codelineno-24-27 name=__codelineno-24-27 href=#__codelineno-24-27></a> res |= ast_register_translator(&amp;lin16tog722);
</span><span id=__span-24-28><a id=__codelineno-24-28 name=__codelineno-24-28 href=#__codelineno-24-28></a>
</span><span id=__span-24-29><a id=__codelineno-24-29 name=__codelineno-24-29 href=#__codelineno-24-29></a> if (res) {
</span><span id=__span-24-30><a id=__codelineno-24-30 name=__codelineno-24-30 href=#__codelineno-24-30></a> unload_module();
</span><span id=__span-24-31><a id=__codelineno-24-31 name=__codelineno-24-31 href=#__codelineno-24-31></a> return AST_MODULE_LOAD_FAILURE;
</span><span id=__span-24-32><a id=__codelineno-24-32 name=__codelineno-24-32 href=#__codelineno-24-32></a> } 
</span><span id=__span-24-33><a id=__codelineno-24-33 name=__codelineno-24-33 href=#__codelineno-24-33></a>
</span><span id=__span-24-34><a id=__codelineno-24-34 name=__codelineno-24-34 href=#__codelineno-24-34></a> return AST_MODULE_LOAD_SUCCESS;
</span><span id=__span-24-35><a id=__codelineno-24-35 name=__codelineno-24-35 href=#__codelineno-24-35></a>}
</span></code></pre></div> <h1 id=handling-multiple-media-streams>Handling Multiple Media Streams<a class=headerlink href=#handling-multiple-media-streams title="Permanent link">&para;</a></h1> <h2 id=problem-overview_3>Problem Overview<a class=headerlink href=#problem-overview_3 title="Permanent link">&para;</a></h2> <p>Asterisk was designed from the ground up with the idea of only one audio media path being passed between channels. The code that handles this media path is done in such a way that makes expanding it to multiple media paths very difficult, especially media that is not audio. Asterisk has gotten away with being able to support very limited video functionality by not treating it as a media path at all. Instead of putting all media in the same media path as audio, video and other forms of media are just passed through similar to the way signalling is done. In order to bring all media into the same code path as audio, several fundamental design changes must be made to the way channels represent media streams. This section discusses those changes and how they affect channel drivers and other applications requiring access to media streams.</p> <h2 id=defining-a-media-stream-in-asterisk>Defining a Media Stream in Asterisk<a class=headerlink href=#defining-a-media-stream-in-asterisk title="Permanent link">&para;</a></h2> <p>The first step in improving Asterisk's ability to represent multiple media streams is to actually define what a media stream is. At the moment, a stream in Asterisk is a very abstract idea. There is no tangible representation of a stream, no stream object or structure. The best representation of a stream Asterisk has now is the ast_channel structure which is capable of representing a single set of audio tx/rx streams through the use of a bunch disjoint elements. Lets start this discussion by breaking out the elements of the ast_channel structure that allow it to represent these streams.</p> <p>In order for the ast_channel structure to represent a single set of audio tx/rx streams it needs the following things.</p> <h1 id=read-translator-translates-stream-on-the-read-path-going-into-the-asterisk-core>*Read translator* - Translates stream on the read path going into the Asterisk Core.<a class=headerlink href=#read-translator-translates-stream-on-the-read-path-going-into-the-asterisk-core title="Permanent link">&para;</a></h1> <h1 id=write-translator-translates-stream-on-the-write-path-going-out-to-the-channel-driver>*Write translator* - Translates stream on the write path going out to the channel driver.<a class=headerlink href=#write-translator-translates-stream-on-the-write-path-going-out-to-the-channel-driver title="Permanent link">&para;</a></h1> <h1 id=native-format-capabilities-native-capabilities-the-channel-driver-is-capable-of-understanding-without-translation-for-this-stream>*Native Format Capabilities* - Native capabilities the channel driver is capable of understanding without translation for this stream.<a class=headerlink href=#native-format-capabilities-native-capabilities-the-channel-driver-is-capable-of-understanding-without-translation-for-this-stream title="Permanent link">&para;</a></h1> <h1 id=read-format-requested-read-format-after-translation-on-the-read-path>*Read Format* - Requested Read format after translation on the read path.<a class=headerlink href=#read-format-requested-read-format-after-translation-on-the-read-path title="Permanent link">&para;</a></h1> <h1 id=raw-read-format-expected-read-format-before-translation>*Raw Read Format* - Expected read format before translation.<a class=headerlink href=#raw-read-format-expected-read-format-before-translation title="Permanent link">&para;</a></h1> <h1 id=write-format-requested-write-format-after-translation-on-the-write-path>*Write Format* - Requested write format after translation on the write path.<a class=headerlink href=#write-format-requested-write-format-after-translation-on-the-write-path title="Permanent link">&para;</a></h1> <h1 id=raw-read-format-expected-write-format-before-translation>*Raw Read Format* - Expected write format before translation.<a class=headerlink href=#raw-read-format-expected-write-format-before-translation title="Permanent link">&para;</a></h1> <p>The combination of all these items represent everything Asterisk needs to make channels compatible with one another and build translation paths between one another for a single set of corresponding tx/rx streams. The problem with this architecture is that all these disjoint elements make it impossible to replicate this functionality allowing for multiple tx/rx streams to exist on a single channel. In order for channels in Asterisk to gain the ability to process multiple tx/rx stream sets on a single channel all of theses stream elements must be organized into an isolated structure that can be easily replicated and manipulated. This new structure is called the *ast_channel_stream* structure and is discussed in detail in the next section.</p> <h2 id=introducing-ast_channel_stream-making-sense-out-of-madness>Introducing ast_channel_stream, Making Sense out of Madness<a class=headerlink href=#introducing-ast_channel_stream-making-sense-out-of-madness title="Permanent link">&para;</a></h2> <p>The ast_channel_stream structure is made up of all the individual elements required to represent single set of tx/rx streams on an ast_channel structure. This allows all the disjoint translators and formats on the ast_channel structure associated with the audio streams go away and be replaced by a single ast_channel_stream structure. Everyplace in the current code base that directly accesses any of the stream elements on a channel such as nativeformats, readformat, and writeformat will be replaced by a set of API functions provided by the new Ast Channel Stream API. This API contains all the common operations channel drivers and applications need to perform on a stream, such as setting the native format capabilities, initializing the read/write formats, retrieving the current read/write formats, and setting the read/write formats. By using this API, channels also gain the ability to contain more than one media stream set. This is done through the concept of stream identifiers which is further discussed in the next section.</p> <h2 id=stream-identifiers>Stream Identifiers<a class=headerlink href=#stream-identifiers title="Permanent link">&para;</a></h2> <p>The ast_channel_stream structure isolates the concept of tx/rx streams to a single entity allowing channels to represent multiple streams through the use of multiple ast_channel_stream structures. Since it is prohibited for any part of Asterisk except channel.c to directly access the ast_channel_stream structures on a channel, the rest of Asterisk needs a way access these individual streams through the use of the Ast Channel Stream API. This introduces the concept of *stream identifiers*. Stream identifiers completely abstract away the concept of the ast_channel_stream structure from the rest of Asterisk. Every ast_channel_stream structure on a channel will have a unique stream id assigned to it. This stream id is required by every function in the Ast Channel Stream API to access and manipulate the individual streams on a channel.</p> <p>In order to separate ast_frames belonging to separate streams, a stream id will also be present on each frame. This will involve placing a new value on the ast_frame structure to represent what stream the frame belongs to. By default the current code will not use the stream id on the ast_frame even though it will be present. This concept is discussed in more detail in the "Default Streams" section.</p> <p>Steam identifiers are organized into three categories. For the sake of organization and ABI compatibility each of these categories are given a range of unique stream identifiers available to them. Separating the default streams from the auxiliary and dynamic streams also makes it much easier to filter out auxiliary and dynamic streams for applications and modules that do not support them. Once a new stream identifier is defined, its unique id must remain consistent. </p> <h1 id=default-streams-unique-id-defined-between-1-99999>*default streams*: Unique id defined between 1 - 99999<a class=headerlink href=#default-streams-unique-id-defined-between-1-99999 title="Permanent link">&para;</a></h1> <h1 id=auxiliary-streams-unique-id-defined-between-100000-199999>*auxiliary streams*: Unique id defined between 100000 - 199999<a class=headerlink href=#auxiliary-streams-unique-id-defined-between-100000-199999 title="Permanent link">&para;</a></h1> <h1 id=dynamic-streams-unique-id-defined-between-200000-299999>*dynamic streams*: Unique id defined between 200000 - 299999<a class=headerlink href=#dynamic-streams-unique-id-defined-between-200000-299999 title="Permanent link">&para;</a></h1> <h3 id=default-streams>Default Streams<a class=headerlink href=#default-streams title="Permanent link">&para;</a></h3> <p>Since Asterisk was designed with the concept of a single audio tx/rx stream set existing on a channel, some provisions must be made to allow for a smooth transition into the concept of multiple stream sets. This is where default streams come into play. Every ast_channel structure will contain a set of default streams associated with it, each with a predefined consistent stream id.</p> <p>*Default Audio Streams* - The first default tx/rx stream set present on every channel is the default audio streams. This is the stream set all of Asterisk already knows about. It is the one that used to be made of individual elements in the ast_channel structure but was stripped out after defining the ast_channel_stream structure. Every channel driver built so far already knows how to manipulate these streams and many applications require access to them as well. All ast_frames of type AST_FRAME_VOICE with a stream id of 0 will automatically match this default stream set on a channel. Since 0 is the default initialization value for the stream id on a frame, all the channel drivers and applications already making use of these streams do not have to be modified.</p> <p>It should be noted that while additional audio streams will be possible in the future, it is likely the default audio stream will be the only one that any kind of tone detection is performed on for DTMF, FAX, etc. This document does not attempt to alter this limitation in any way.</p> <p>*Default Video Streams* - It is currently impossible to do translation between two channels transmitting different video formats because the channel has no way of representing video translators. This changes with the introduction of the default video rx/tx stream set. Similar to the default audio streams, any video frames containing a stream Id of 0 is automatically matched to the default video stream set on a channel.</p> <p>As more media types are introduced, it may be beneficial to define additional default stream sets. Initially only audio and video will present.</p> <h3 id=auxiliary-streams>Auxiliary Streams<a class=headerlink href=#auxiliary-streams title="Permanent link">&para;</a></h3> <p>If a channel driver is capable of negotiating more streams than can be represented by the default rx/tx stream sets on a channel, the auxiliary media stream sets can be used. These stream sets work the exact same way as the default stream sets except they require the use of the media stream id on frames. With auxiliary streams the stream id must be present on every ast_frame created for the stream. This allows channels and applications not capable of processing auxiliary streams to filter out the frames they don't understand.</p> <p>Since Asterisk supports multiple protocols with various capabilities, all the auxiliary streams that can be used anywhere in Asterisk must be defined at compile time. This means when a channel driver is extended to make use of a new type of auxiliary stream, that stream must be defined with a stream id that uniquely represents it across the entire code base. This is the only way to keep the different types of auxiliary streams and what they are used for consistent across all modules.</p> <div class="language-text highlight"><pre><span></span><code><span id=__span-25-1><a id=__codelineno-25-1 name=__codelineno-25-1 href=#__codelineno-25-1></a>Example 1: Chan_sip is extended to make use of up to four video and audio streams per call. This sort of functionality has never been done before so six new auxiliary streams must be defined for the three new video and three new audio streams.
</span><span id=__span-25-2><a id=__codelineno-25-2 name=__codelineno-25-2 href=#__codelineno-25-2></a>
</span><span id=__span-25-3><a id=__codelineno-25-3 name=__codelineno-25-3 href=#__codelineno-25-3></a>enum ast_channel_stream_id {
</span><span id=__span-25-4><a id=__codelineno-25-4 name=__codelineno-25-4 href=#__codelineno-25-4></a> /*! Define Default Streams belo */
</span><span id=__span-25-5><a id=__codelineno-25-5 name=__codelineno-25-5 href=#__codelineno-25-5></a> AST_STREAM_DEFAULT_AUDIO = 1,
</span><span id=__span-25-6><a id=__codelineno-25-6 name=__codelineno-25-6 href=#__codelineno-25-6></a> AST_STREAM_DEFAULT_VIDEO = 2,
</span><span id=__span-25-7><a id=__codelineno-25-7 name=__codelineno-25-7 href=#__codelineno-25-7></a>
</span><span id=__span-25-8><a id=__codelineno-25-8 name=__codelineno-25-8 href=#__codelineno-25-8></a> /*! Define Auxiliary Streams Belo */
</span><span id=__span-25-9><a id=__codelineno-25-9 name=__codelineno-25-9 href=#__codelineno-25-9></a> AST_STREAM_VIDEO_AUX1 = 100000,
</span><span id=__span-25-10><a id=__codelineno-25-10 name=__codelineno-25-10 href=#__codelineno-25-10></a> AST_STREAM_VIDEO_AUX2, = 100001,
</span><span id=__span-25-11><a id=__codelineno-25-11 name=__codelineno-25-11 href=#__codelineno-25-11></a> AST_STREAM_VIDEO_AUX3, = 100002,
</span><span id=__span-25-12><a id=__codelineno-25-12 name=__codelineno-25-12 href=#__codelineno-25-12></a> AST_STREAM_AUDIO_AUX1, = 100003,
</span><span id=__span-25-13><a id=__codelineno-25-13 name=__codelineno-25-13 href=#__codelineno-25-13></a> AST_STREAM_AUDIO_AUX2, = 100004,
</span><span id=__span-25-14><a id=__codelineno-25-14 name=__codelineno-25-14 href=#__codelineno-25-14></a> AST_STREAM_AUDIO_AUX3, = 100005,
</span><span id=__span-25-15><a id=__codelineno-25-15 name=__codelineno-25-15 href=#__codelineno-25-15></a>}
</span><span id=__span-25-16><a id=__codelineno-25-16 name=__codelineno-25-16 href=#__codelineno-25-16></a>
</span><span id=__span-25-17><a id=__codelineno-25-17 name=__codelineno-25-17 href=#__codelineno-25-17></a>As chan_sip receives individual stream payloads and creates ast_frames to pass into the core, each frame&#39;s stream id is marked with the ast_channel_stream_id it belongs to. Any channel driver or applications that gets passed an audio or video frame belonging to one of these newly defined auxiliary streams that does not support it will ignore it.
</span></code></pre></div> <h3 id=dynamic-streams>Dynamic Streams<a class=headerlink href=#dynamic-streams title="Permanent link">&para;</a></h3> <p>It is possible that Asterisk will need the ability to pass through streams containing media it does not understand. This can only be accomplished if both the channel negotiating the unknown media type and whatever that channel is bridged too can agree that they both understand the unknown media type and are assigning it a dynamic stream id that they both agree upon. This document does not define the negotiation of dynamic streams in Asterisk.</p> <h2 id=ast-channel-stream-api-defined>Ast Channel Stream API Defined<a class=headerlink href=#ast-channel-stream-api-defined title="Permanent link">&para;</a></h2> <p><div class="language-text highlight"><pre><span></span><code><span id=__span-26-1><a id=__codelineno-26-1 name=__codelineno-26-1 href=#__codelineno-26-1></a>/*! \brief Definition of opaque channel stream structur */
</span><span id=__span-26-2><a id=__codelineno-26-2 name=__codelineno-26-2 href=#__codelineno-26-2></a>struct ast_channel_stream {
</span><span id=__span-26-3><a id=__codelineno-26-3 name=__codelineno-26-3 href=#__codelineno-26-3></a> /*! represents the stream typ */
</span><span id=__span-26-4><a id=__codelineno-26-4 name=__codelineno-26-4 href=#__codelineno-26-4></a> enum ast_channel_stream_id id;
</span><span id=__span-26-5><a id=__codelineno-26-5 name=__codelineno-26-5 href=#__codelineno-26-5></a>
</span><span id=__span-26-6><a id=__codelineno-26-6 name=__codelineno-26-6 href=#__codelineno-26-6></a> struct ast_trans_pvt *writetrans;
</span><span id=__span-26-7><a id=__codelineno-26-7 name=__codelineno-26-7 href=#__codelineno-26-7></a> struct ast_trans_pvt *readtrans;
</span><span id=__span-26-8><a id=__codelineno-26-8 name=__codelineno-26-8 href=#__codelineno-26-8></a>
</span><span id=__span-26-9><a id=__codelineno-26-9 name=__codelineno-26-9 href=#__codelineno-26-9></a> struct ast_cap nativeformats;
</span><span id=__span-26-10><a id=__codelineno-26-10 name=__codelineno-26-10 href=#__codelineno-26-10></a>
</span><span id=__span-26-11><a id=__codelineno-26-11 name=__codelineno-26-11 href=#__codelineno-26-11></a> struct ast_format readformat;
</span><span id=__span-26-12><a id=__codelineno-26-12 name=__codelineno-26-12 href=#__codelineno-26-12></a> struct ast_format writeformat;
</span><span id=__span-26-13><a id=__codelineno-26-13 name=__codelineno-26-13 href=#__codelineno-26-13></a> struct ast_format rawreadformat;
</span><span id=__span-26-14><a id=__codelineno-26-14 name=__codelineno-26-14 href=#__codelineno-26-14></a> struct ast_format rawwriteformat;
</span><span id=__span-26-15><a id=__codelineno-26-15 name=__codelineno-26-15 href=#__codelineno-26-15></a>};
</span></code></pre></div> <div class="language-text highlight"><pre><span></span><code><span id=__span-27-1><a id=__codelineno-27-1 name=__codelineno-27-1 href=#__codelineno-27-1></a>/*! \brief stream identifier structure. Present on both ast_frame
</span><span id=__span-27-2><a id=__codelineno-27-2 name=__codelineno-27-2 href=#__codelineno-27-2></a> * and ast_channel_stream structure.
</span><span id=__span-27-3><a id=__codelineno-27-3 name=__codelineno-27-3 href=#__codelineno-27-3></a> */
</span><span id=__span-27-4><a id=__codelineno-27-4 name=__codelineno-27-4 href=#__codelineno-27-4></a>enum ast_channel_stream_id {
</span><span id=__span-27-5><a id=__codelineno-27-5 name=__codelineno-27-5 href=#__codelineno-27-5></a> /*! Define all Default Streams below */
</span><span id=__span-27-6><a id=__codelineno-27-6 name=__codelineno-27-6 href=#__codelineno-27-6></a> AST_STREAM_DEFAULT_AUDIO = 1,
</span><span id=__span-27-7><a id=__codelineno-27-7 name=__codelineno-27-7 href=#__codelineno-27-7></a> AST_STREAM_DEFAULT_VIDEO = 2,
</span><span id=__span-27-8><a id=__codelineno-27-8 name=__codelineno-27-8 href=#__codelineno-27-8></a>
</span><span id=__span-27-9><a id=__codelineno-27-9 name=__codelineno-27-9 href=#__codelineno-27-9></a> /*! Define Auxiliary Streams Below starting at 100000
</span><span id=__span-27-10><a id=__codelineno-27-10 name=__codelineno-27-10 href=#__codelineno-27-10></a> * Example:
</span><span id=__span-27-11><a id=__codelineno-27-11 name=__codelineno-27-11 href=#__codelineno-27-11></a> * AST_STREAM_VIDEO_AUX1 = 100000,
</span><span id=__span-27-12><a id=__codelineno-27-12 name=__codelineno-27-12 href=#__codelineno-27-12></a> */
</span><span id=__span-27-13><a id=__codelineno-27-13 name=__codelineno-27-13 href=#__codelineno-27-13></a>}
</span><span id=__span-27-14><a id=__codelineno-27-14 name=__codelineno-27-14 href=#__codelineno-27-14></a>
</span><span id=__span-27-15><a id=__codelineno-27-15 name=__codelineno-27-15 href=#__codelineno-27-15></a>void ast_channel_init_write_format(struct ast_channel *chan, enum ast_channel_stream_id id, struct ast_format *format)
</span><span id=__span-27-16><a id=__codelineno-27-16 name=__codelineno-27-16 href=#__codelineno-27-16></a>
</span><span id=__span-27-17><a id=__codelineno-27-17 name=__codelineno-27-17 href=#__codelineno-27-17></a>void ast_channel_init_read_format(struct ast_channel *chan, enum ast_channel_stream_id id, struct ast_format *format)
</span><span id=__span-27-18><a id=__codelineno-27-18 name=__codelineno-27-18 href=#__codelineno-27-18></a>
</span><span id=__span-27-19><a id=__codelineno-27-19 name=__codelineno-27-19 href=#__codelineno-27-19></a>void ast_channel_set_native_cap(struct ast_channel *chan, enum ast_channel_stream_id id, struct ast_cap *cap)
</span><span id=__span-27-20><a id=__codelineno-27-20 name=__codelineno-27-20 href=#__codelineno-27-20></a>
</span><span id=__span-27-21><a id=__codelineno-27-21 name=__codelineno-27-21 href=#__codelineno-27-21></a>int ast_channel_copy_readwrite_format(struct ast_channel *chan1, struct ast_channel *chan2, enum ast_channel_stream_id id)
</span><span id=__span-27-22><a id=__codelineno-27-22 name=__codelineno-27-22 href=#__codelineno-27-22></a>
</span><span id=__span-27-23><a id=__codelineno-27-23 name=__codelineno-27-23 href=#__codelineno-27-23></a>void ast_channel_set_read_format(struct ast_channel *chan, enum ast_channel_stream_id id, struct ast_format *format)
</span><span id=__span-27-24><a id=__codelineno-27-24 name=__codelineno-27-24 href=#__codelineno-27-24></a>
</span><span id=__span-27-25><a id=__codelineno-27-25 name=__codelineno-27-25 href=#__codelineno-27-25></a>void ast_channel_set_write_format(struct ast_channel *chan, enum ast_channel_stream_id id, struct ast_format *format)
</span><span id=__span-27-26><a id=__codelineno-27-26 name=__codelineno-27-26 href=#__codelineno-27-26></a>
</span><span id=__span-27-27><a id=__codelineno-27-27 name=__codelineno-27-27 href=#__codelineno-27-27></a>int ast_channel_get_native_cap(struct ast_channel *chan, enum ast_channel_stream_id id, struct ast_cap *result)
</span><span id=__span-27-28><a id=__codelineno-27-28 name=__codelineno-27-28 href=#__codelineno-27-28></a>
</span><span id=__span-27-29><a id=__codelineno-27-29 name=__codelineno-27-29 href=#__codelineno-27-29></a>int ast_channel_get_write_format(struct ast_channel *chan, enum ast_channel_stream_id id, struct ast_format *result)
</span><span id=__span-27-30><a id=__codelineno-27-30 name=__codelineno-27-30 href=#__codelineno-27-30></a>
</span><span id=__span-27-31><a id=__codelineno-27-31 name=__codelineno-27-31 href=#__codelineno-27-31></a>int ast_channel_get_read_format(struct ast_channel *chan, enum ast_channel_stream_id id, struct ast_format *result)
</span></code></pre></div></p> <h2 id=code-change-examples>Code Change Examples<a class=headerlink href=#code-change-examples title="Permanent link">&para;</a></h2> <p>This sections shows how the Ast Channel Stream API replaces existing usage in Asterisk.</p> <p>Example 1: A channel driver creating a new channel and initializing the default audio stream's formats and capabilities.</p> <p><div class="language-text highlight"><pre><span></span><code><span id=__span-28-1><a id=__codelineno-28-1 name=__codelineno-28-1 href=#__codelineno-28-1></a>chan-&gt;nativeformats = capabilty;
</span><span id=__span-28-2><a id=__codelineno-28-2 name=__codelineno-28-2 href=#__codelineno-28-2></a>chan-&gt;readformat = best_format;
</span><span id=__span-28-3><a id=__codelineno-28-3 name=__codelineno-28-3 href=#__codelineno-28-3></a>chan-&gt;rawreadformat = best_format;
</span><span id=__span-28-4><a id=__codelineno-28-4 name=__codelineno-28-4 href=#__codelineno-28-4></a>chan-&gt;writeformat = best_format;
</span><span id=__span-28-5><a id=__codelineno-28-5 name=__codelineno-28-5 href=#__codelineno-28-5></a>chan-&gt;rawwriteformat = best_format;
</span></code></pre></div> <div class="language-text highlight"><pre><span></span><code><span id=__span-29-1><a id=__codelineno-29-1 name=__codelineno-29-1 href=#__codelineno-29-1></a>ast_channel_set_native_cap(chan, AST_STREAM_DEFAULT_AUDIO, capability);
</span><span id=__span-29-2><a id=__codelineno-29-2 name=__codelineno-29-2 href=#__codelineno-29-2></a>ast_channel_init_write_format(chan, AST_STREAM_DEFAULT_AUDIO, best_format);
</span><span id=__span-29-3><a id=__codelineno-29-3 name=__codelineno-29-3 href=#__codelineno-29-3></a>ast_channel_init_read_format(chan, AST_STREAM_DEFAULT_AUDIO, best_format);
</span></code></pre></div></p> <p>Example 2: Setting the read format on a channel.</p> <p><div class="language-text highlight"><pre><span></span><code><span id=__span-30-1><a id=__codelineno-30-1 name=__codelineno-30-1 href=#__codelineno-30-1></a>ast_set_read_format(chan, format);
</span></code></pre></div> <div class="language-text highlight"><pre><span></span><code><span id=__span-31-1><a id=__codelineno-31-1 name=__codelineno-31-1 href=#__codelineno-31-1></a>ast_set_read_format(chan, AST_STREAM_DEFAULT_AUDIO, format);
</span></code></pre></div></p> <h1 id=media-format-with-attributes-user-configuration>Media Format with Attributes User Configuration<a class=headerlink href=#media-format-with-attributes-user-configuration title="Permanent link">&para;</a></h1> <p>With the addtion of media formats with attributes, users will need a way to represent these new formats and their attributes in their config files. This will be accomplished by the ability to define custom media types that can be used in the format allow/disallow fields. These custom media type definitions will live in codecs.conf. For people familiar with Asterisk's config structure, the best way to present this concept is with some examples.</p> <p>*Example 1*. SILK is capable of several different sample rates. If a peer wants to negotiate only using SILK in a narrow band format, a custom format must be created to represent this.</p> <p><div class="language-text highlight"><pre><span></span><code><span id=__span-32-1><a id=__codelineno-32-1 name=__codelineno-32-1 href=#__codelineno-32-1></a>/* Limit negotiation of SILK to only 8khz and 12khz */
</span><span id=__span-32-2><a id=__codelineno-32-2 name=__codelineno-32-2 href=#__codelineno-32-2></a>[silk_nb]
</span><span id=__span-32-3><a id=__codelineno-32-3 name=__codelineno-32-3 href=#__codelineno-32-3></a>type=silk
</span><span id=__span-32-4><a id=__codelineno-32-4 name=__codelineno-32-4 href=#__codelineno-32-4></a>samplerates=8000,12000
</span><span id=__span-32-5><a id=__codelineno-32-5 name=__codelineno-32-5 href=#__codelineno-32-5></a>
</span><span id=__span-32-6><a id=__codelineno-32-6 name=__codelineno-32-6 href=#__codelineno-32-6></a>/* Limit negotiation of SILK to only 16khz and 24kh */
</span><span id=__span-32-7><a id=__codelineno-32-7 name=__codelineno-32-7 href=#__codelineno-32-7></a>[silk_wb]
</span><span id=__span-32-8><a id=__codelineno-32-8 name=__codelineno-32-8 href=#__codelineno-32-8></a>type=silk
</span><span id=__span-32-9><a id=__codelineno-32-9 name=__codelineno-32-9 href=#__codelineno-32-9></a>samplerates=16000,24000
</span><span id=__span-32-10><a id=__codelineno-32-10 name=__codelineno-32-10 href=#__codelineno-32-10></a>
</span><span id=__span-32-11><a id=__codelineno-32-11 name=__codelineno-32-11 href=#__codelineno-32-11></a>/* Allow any SILK sample rate a device is capable of to be negotiate */
</span><span id=__span-32-12><a id=__codelineno-32-12 name=__codelineno-32-12 href=#__codelineno-32-12></a>[silk_all]
</span><span id=__span-32-13><a id=__codelineno-32-13 name=__codelineno-32-13 href=#__codelineno-32-13></a>type=silk
</span><span id=__span-32-14><a id=__codelineno-32-14 name=__codelineno-32-14 href=#__codelineno-32-14></a>samplerates=8000,12000,16000,24000
</span></code></pre></div> <div class="language-text highlight"><pre><span></span><code><span id=__span-33-1><a id=__codelineno-33-1 name=__codelineno-33-1 href=#__codelineno-33-1></a>/* Define a peer using only the narrow band custom SILK format definitio */
</span><span id=__span-33-2><a id=__codelineno-33-2 name=__codelineno-33-2 href=#__codelineno-33-2></a>[sip_peer]
</span><span id=__span-33-3><a id=__codelineno-33-3 name=__codelineno-33-3 href=#__codelineno-33-3></a>type=friend
</span><span id=__span-33-4><a id=__codelineno-33-4 name=__codelineno-33-4 href=#__codelineno-33-4></a>host=dynamic
</span><span id=__span-33-5><a id=__codelineno-33-5 name=__codelineno-33-5 href=#__codelineno-33-5></a>disallow=all
</span><span id=__span-33-6><a id=__codelineno-33-6 name=__codelineno-33-6 href=#__codelineno-33-6></a>allow=silk_nb
</span></code></pre></div></p> <p>*Example 2*. H.264 is capable of negotiating a wide range of attributes. If specific attributes are to be negotiated, a custom format must be created to represent this.</p> <p><div class="language-text highlight"><pre><span></span><code><span id=__span-34-1><a id=__codelineno-34-1 name=__codelineno-34-1 href=#__codelineno-34-1></a>/* H.264 at vga or svga resolutions, 30 frames per second */
</span><span id=__span-34-2><a id=__codelineno-34-2 name=__codelineno-34-2 href=#__codelineno-34-2></a>[h264_custom1]
</span><span id=__span-34-3><a id=__codelineno-34-3 name=__codelineno-34-3 href=#__codelineno-34-3></a>type=h264
</span><span id=__span-34-4><a id=__codelineno-34-4 name=__codelineno-34-4 href=#__codelineno-34-4></a>res=vga,svga
</span><span id=__span-34-5><a id=__codelineno-34-5 name=__codelineno-34-5 href=#__codelineno-34-5></a>framerate=30
</span></code></pre></div> <div class="language-text highlight"><pre><span></span><code><span id=__span-35-1><a id=__codelineno-35-1 name=__codelineno-35-1 href=#__codelineno-35-1></a>/* Define a peer using the new h264_custom1 custom format type */
</span><span id=__span-35-2><a id=__codelineno-35-2 name=__codelineno-35-2 href=#__codelineno-35-2></a>[sip_peer]
</span><span id=__span-35-3><a id=__codelineno-35-3 name=__codelineno-35-3 href=#__codelineno-35-3></a>type=friend
</span><span id=__span-35-4><a id=__codelineno-35-4 name=__codelineno-35-4 href=#__codelineno-35-4></a>host=dynamic
</span><span id=__span-35-5><a id=__codelineno-35-5 name=__codelineno-35-5 href=#__codelineno-35-5></a>disallow=all
</span><span id=__span-35-6><a id=__codelineno-35-6 name=__codelineno-35-6 href=#__codelineno-35-6></a>allow_ulaw
</span><span id=__span-35-7><a id=__codelineno-35-7 name=__codelineno-35-7 href=#__codelineno-35-7></a>allow=h264_custom1
</span></code></pre></div></p> <p>Notice from these examples that both the SILK and H264 custom formats are defined using fields specific to their format. Each format will define what fields are applicable to them. If there are common fields used for several different media formats, those fields should be named in a consistent way across all the media formats that use them. Every format allowing custom media formats to be defined must be documented in codecs.conf along with all the available fields.</p> <h1 id=enhancing-format-negotiation-during-call-setup>Enhancing Format Negotiation During Call Setup<a class=headerlink href=#enhancing-format-negotiation-during-call-setup title="Permanent link">&para;</a></h1> <p warning=warning>{warning} This is an area of focus for our initial media overhaul efforts, but research into this area is still incomplete. Because of this, the design surrounding the ability to better negotiate media formats during call setup has not yet been defined. This will be addressed at a later date.</p> <h1 id=format-renegotiation-after-call-setup>Format Renegotiation After Call Setup<a class=headerlink href=#format-renegotiation-after-call-setup title="Permanent link">&para;</a></h1> <p warning=warning>{warning} Please note that this section is incomplete. A very high level approach to format renegotiation has been outlined below, but many details pertaining to exactly how this will work are not yet defined. Format renegotiation has been marked as one of the later implementation phases and the design will be completely re-evaluated and proven before implementation.</p> <h2 id=problem-overview_4>Problem Overview<a class=headerlink href=#problem-overview_4 title="Permanent link">&para;</a></h2> <p>When it is at all possible, it is always better to have two bridged channels share the same media formats for their audio streams than to have to perform translation. Translation for audio is expensive, but translation for video is exponentially more expensive that audio. Because of the computational complexity involved with translating video, the concept of being able to renegotiate media after a call is estabilshed in an attempt to get the device to do the translation for us is very important. Right now Asterisk lacks this ability.</p> <h2 id=making-ast_channel_make_compatible-smarter>Making ast_channel_make_compatible() Smarter<a class=headerlink href=#making-ast_channel_make_compatible-smarter title="Permanent link">&para;</a></h2> <p>Every time a channel is bridged with another channel a call to ast_channel_make_compatible() is made. This function takes the two channels to be bridged as input and figures out all the translation paths and intermediate media formats that need to be set in order for the two channels to talk to each other. With protocols like SIP, it is possible to renegotiate the call parameters after call setup has taken place. By placing a feature in ast_channel_make_compatible() that can make the two channels aware of each other's native media format before translation takes place, it is possible for one side to re-negotiate its session to switch to the same media format used by the other side. When this is possible, Asterisk is able to avoid translation completely.</p> <h3 id=how-renegotiation-works>How Renegotiation Works<a class=headerlink href=#how-renegotiation-works title="Permanent link">&para;</a></h3> <p>At the heart of renegotiation is the introduction of a channel option called *AST_OPTION_FORMAT_RENEGOTIATE* and a structure called *ast_option_renegotiate_param*. The ast_format_renegotiate_param structure is passed as the data for the AST_OPTION_FORMAT_RENEGOTIATE's query and set actions. This structure contains both a format to renegotiate for each stream renegotation must take place on, a function pointer containing the place a channel tech must report the result of its renegotiation attempt, and an internal structure used to determine what action to take next after a channel tech reports the renegotiation attempt.</p> <p>On query, the ast_option_renegotiate_param structure is passed down to the channel tech pvt containing information about all the formats and streams to renegotiate. The result of a query request indicates whether or not the channel tech is capable of attempting renegotiation with the formats provided or not. Queries are performed synchronously, meaning the result of a query request must never block for a network transaction to take place.</p> <p>On set, the ast_option_renegotiate_param structure is passed down to the channel tech pvt containing both the formats and streams to renegotiate along with a place to report the result of the renegotiation. Renegotiation is event driven, meaning that the channel tech pvt is given the renegotation parameters and it must report back at a later time the result of the renegotiation attempt. This allows the set operation to avoid blocking the bridge code by performing the renegotation asynchronously.</p> <p>During ast_channel_make_compatible(), if it is determined that translation is required to make two channels compatible both channels are queried using the AST_OPTION_FORMAT_RENEGOTIATE option and ast_option_renegotiate_param structures. After the queries, if either of the two channels are capable of renegotiating the set action is used on best candidate to attempt the renegotiation. If the channel used for the first renegotiation attempt reports a failure, a second attempt at renegotiation may take place for the bridged channel if neither channel has hung up.</p> <h3 id=renegotiation-with-intermediary-translation>Renegotiation with Intermediary Translation<a class=headerlink href=#renegotiation-with-intermediary-translation title="Permanent link">&para;</a></h3> <ul> <li>Make Compatible Flow of Events<ul> <li>ast_channel_make_compatible() is invoked</li> <li>read and write formats are different between channels for at least one stream</li> <li>translation paths are built for streams requiring translation</li> <li>query to AST_OPTION_FORMAT_RENEGOTIATE is made on both channels</li> <li>if candidate for renegotation exists, renegotiation parameters are set to the channel using AST_OPTION_FORMAT_RENEGOTIATE</li> <li>channels are bridged</li> </ul> </li> <li>Asynchronous Renegotation Flow of Events<ul> <li>channel tech is set with renegotation paramters using AST_OPTION_FORMAT_RENEGOTIATE</li> <li>channel tech attempts renegotiation and reports result to renegotiation parameter result function *** on SUCCESS: new format is set for renegotated stream and translation path goes away *** on FAILURE: result function attempts renegotation with bridged channel if possible, else translation must remain</li> </ul> </li> </ul> <h3 id=renegotiation-with-no-intermediary-translation>Renegotiation with no Intermediary Translation<a class=headerlink href=#renegotiation-with-no-intermediary-translation title="Permanent link">&para;</a></h3> <ul> <li>Make Compatible Flow of Events<ul> <li>ast_channel_make_compatible() is invoked</li> <li>channel's read and write formats are different for at least one stream</li> <li>*NO* translation path is possible to make channels compatible</li> <li>query to AST_OPTION_FORMAT_RENEGOTIATE is made to both channels</li> <li>if best candidate for renegotiation is found, renegotiation parameters are set to the channel using AST_OPTION_FORMAT_RENEGOTIATE</li> <li>channel is bridged</li> <li>media for incompatible streams are blocked for a period of time while renegotiation takes place</li> </ul> </li> <li>Asynchronous Renegotiation Flow of Events<ul> <li>channel tech is set with renegotiation parameters using AST_OPTION_FORMAT_RENEGOTIATE.</li> <li>channel tech attempts renegotiation and reports result to renegotiation parameter result function *** on SUCCESS: new format is set for renegotiated stream and translation path goes away *** on FAILURE: result function attempts renegotiation with bridged channel if possible</li> <li>if renegotiation fails on both channels, depending on the stream in question media is either indefinitely blocked or both channels are hung up</li> </ul> </li> </ul> <h1 id=implementation-phases>Implementation Phases<a class=headerlink href=#implementation-phases title="Permanent link">&para;</a></h1> <p>With a project of this size, it is important to break down the implementation into manageable phases. Each phase of development contains a set of steps which act as milestones. These steps must be small enough to be attainable within a week to two week period but complete enough not to break any Asterisk functionality once they are introduced. Once a step is complete, it should be reviewed and committed into trunk. This allows progress to be made in a maintainable way.</p> <h2 id=phase-1-re-architect-how-media-is-represented-and-how-translation-paths-are-built>Phase 1: Re-architect how media is represented and how translation paths are built<a class=headerlink href=#phase-1-re-architect-how-media-is-represented-and-how-translation-paths-are-built title="Permanent link">&para;</a></h2> <p>From the user perspective, no functionality changes will be present during this phase.</p> <ul> <li> <p>Step 1</p> <ul> <li>Define new format unique ID system using numbers rather than bits. Allow this definition to remain unused during this step except by the new APIs.</li> <li>Create Ast Format API + unit tests.</li> <li>Create Ast Capibility API + unit tests.</li> <li>Create IAX2 Conversion layer for ast_format and ast_cap objects. Create unit tests and leave this layer inactive until conversion to new APIs takes place.</li> </ul> </li> <li> <p>Step 2</p> <ul> <li>Define translation cost table.</li> <li>Replace current matrix algorithm with new matrix algorithm using predefined costs from table.</li> <li>Continue to use computational costs for tie breaking translators with identical src and dst formats.</li> <li>Create table for mapping format ids to matrix index values. This is required once the conversion from the format bit field representation to a numeric value takes place and will allow for a smoother transition.</li> </ul> </li> <li> <p>Step 3</p> <ul> <li>Replace old format unique ID system with the new system. This will temporarily break all asterisk media functionality.</li> <li>Add media functionality back into Asterisk by replacing all instances of format_t with ast_format and ast_cap.</li> <li>Completely remove format_t type def.</li> </ul> </li> </ul> <h2 id=phase-2-exercise-the-functionality-introduced-by-formats-with-attributes>Phase 2: Exercise the functionality introduced by formats with attributes<a class=headerlink href=#phase-2-exercise-the-functionality-introduced-by-formats-with-attributes title="Permanent link">&para;</a></h2> <p>This is done by introducing the SILK codec and allowing H.264 to be negotiated with format attributes.</p> <ul> <li> <p>Step 1</p> <ul> <li>Define SILK format in Asterisk.</li> <li>Create SILK format attribute interface.</li> <li>Make SILK translators to and from signed linear.</li> <li>Add the ability to define custom media formats with attributes in user configuration.</li> <li>Extend the rtp mapping code to allow chan_sip to advertise SILK appropriately in SDPs.</li> </ul> </li> <li> <p>Step 2</p> <ul> <li>Create H.264 format attribute interface.</li> <li>Extend codecs.conf to allow custom H.264 format definitions.</li> <li>Extend chan_sip to be able to correctly advertise and negotiate H.264 with attributes in SDPs.</li> </ul> </li> </ul> <h2 id=phase-3-extend-asterisk-to-handle-multiple-media-streams>Phase 3: Extend Asterisk to handle multiple media streams<a class=headerlink href=#phase-3-extend-asterisk-to-handle-multiple-media-streams title="Permanent link">&para;</a></h2> <ul> <li> <p>Step 1</p> <ul> <li>Create Ast Channel Stream API</li> <li>Define default audio stream by replacing current audio stream formats and translators on a channel with an ast_channel_stream structure.</li> <li>Define default video stream by introducing a new ast_channel_stream structure used solely for negotiating the primary video stream.</li> </ul> </li> <li> <p>Step 2</p> <ul> <li>Add the stream id field to the ast_frame structure.</li> <li>Block the ability to read anything other than the default streams with all current channel drivers and applications.</li> <li>Introduce new ast_read functionality for reading auxiliary streams when it is explicitly requested.</li> </ul> </li> <li> <p>Step 3</p> <ul> <li>Exercise the new ability to build video translation paths using an FFMPEG addon translation module.</li> </ul> </li> </ul> <h2 id=phase-4-format-renegotiation-after-call-setup>Phase 4: Format Renegotiation after call setup<a class=headerlink href=#phase-4-format-renegotiation-after-call-setup title="Permanent link">&para;</a></h2> <p>Allowing calls to renegotiate their media formats after call setup is perhaps the most practical functionality introduced by this project. Due to the way multiple media streams will be represented in Asterisk, this ability to represent multiple streams is prerequisite for format renegotiation be implemented correctly. That is the primary reasoning for pushing back the introduction of this functionality to a later phase.</p> <ul> <li> <p>Step 1</p> <ul> <li>Re-evaluate design. Define use cases and prove concept with a set of sequence diagrams.</li> <li>Test interoperability of renegotiation use cases using sipp scenarios against common SIP devices.</li> </ul> </li> <li> <p>Step 2</p> <ul> <li>Implement core functionality changes required to detect and attempt format renegotiation with channel techs.</li> <li>Implement chan_sip configuration options and functionality required to allow format renegotiation triggered by the Asterisk core to occur after call setup.</li> </ul> </li> </ul> </article> </div> <script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script> </div> <button type=button class="md-top md-icon" data-md-component=top hidden> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8z"/></svg> Back to top </button> </main> <footer class=md-footer> <div class="md-footer-meta md-typeset"> <div class="md-footer-meta__inner md-grid"> <div class=md-copyright> <div class=md-copyright__highlight> Content is licensed under a Creative Commons Attribution-ShareAlike 3.0 United States License. </div> Made with <a href=https://squidfunk.github.io/mkdocs-material/ target=_blank rel=noopener> Material for MkDocs </a> </div> <div class=md-social> <a href=https://www.asterisk.org/ target=_blank rel=noopener title=www.asterisk.org class=md-social__link> <?xml version="1.0" encoding="UTF-8" standalone="no"?> <svg version=1.1 id=svg2 width=48 height=48 viewbox="0 0 48 48" sodipodi:docname=favicon.svg inkscape:version="1.2.2 (b0a8486541, 2022-12-01)" xmlns:inkscape=http://www.inkscape.org/namespaces/inkscape xmlns:sodipodi=http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd xmlns:xlink=http://www.w3.org/1999/xlink xmlns=http://www.w3.org/2000/svg xmlns:svg=http://www.w3.org/2000/svg> <defs id=defs6 /> <sodipodi:namedview id=namedview4 pagecolor=#ffffff bordercolor=#666666 borderopacity=1.0 inkscape:showpageshadow=2 inkscape:pageopacity=0.0 inkscape:pagecheckerboard=0 inkscape:deskcolor=#d1d1d1 showgrid=false inkscape:zoom=17.291667 inkscape:cx=24 inkscape:cy=24.028916 inkscape:current-layer=g8 /> <g inkscape:groupmode=layer inkscape:label=Image id=g8> <image width=48 height=48 preserveaspectratio=none id=image10 xlink:href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAABHNCSVQICAgIfAhkiAAACzxJREFU
aIHtmXuQXNVxxn997jz3qRdasay0s5IMiQCDIx4JqaSwjQFDoGIXAhUVMAajgF0kAWShB48xDy2W
eLmoOLbsFBHGBahcgYTEBAJBhYNLxsjEWKEko6BdJCEJSWi1O7O7M3Pv+fLHvmZ3Z1YrYZJ/+Kqm
am6fPt393XNud5974RN8go8E+ziNK4s70HtSbTpWrCl5pdMxFy9FYdx8EBdRKBcrxeWLUUR/nyXz
M2q25S2LPxofHwuB/LLZzVEQnGXyp2HuJEythh0PTAXSoADMA33AIcFeEzvMsRVpc6RwU3377g/3
LW2qmfXAvvz/CQEJy9/ZcorC2DeccZ5gOtAAuEGVItIHODuIKCDiGNMMZgmSgzoeowuxXfgHEwrf
Kvj4tM3pztc/myX8WAgom0kVC35uyexWwxYLUkAXsB/pVx694nz0evchvdO87v3esfN33tySnl4T
P7XkdbEzLjXIAI2ASTwdmH8NXCxU6fGG9t0Hf6cE+pZnMnLc4I2vmDRDst/g+HeTXhXujdrVOz4w
0GTtHbxpfkO6rnSezK4GLhTEgP/00i9jxqySi+5uvHfXO78TAodXzr4gwD2CbJ4ZuyTucS58Mb2/
6QNbt7l0rHYF1n1zy9QgHVwH3A+GxFbQf5jZjND7r0+5/71Dx0xAS5tq8/H09Rh3I/I4Hi+GbvW0
b797+FiDrobcisxXZTxi0IB4E6MGaV3t6s6HzQZW9qgIdK84Ybpz8TsRfwG8JvRwXaLzZzbmAeu5
Y87JLuScclkEexra3/uXo/Gnm1vS+bS7A9wtCDD2AnUu4OKaezp+MWkCyuLyxZnHQc0PQJ8DvisV
1ta3791fmWjb9YHpO6OEppdr7+u85GgIAOz/m9bj0zX2b8CngSIQk/RKV390yeyHd/W5iSYruyBx
YNnxv0+xtQnSDwj+1MTq2kTnymrBAzgUCtKjfxO6qorjHunc46RvAR5IAM7MTm9IB+cO+Jog+Fx/
9zn1ybjrxe5CnOvEbTXJzvuHtowWEVRh0D/OnihUUt1QzUYZ0gc7n0O8WSaaGsjO3ZJdkKhKoKfQ
c7ZzwfxS6JYIFoM9uCNZ89hQqd9xTSaVn5/5cX757DM1ZivKa1ywJj+OVO+yE1ouOrH1sdzKzOkT
EbB1lDB+VCZyzrTwZLoaKhLov735pJhzWYNGjKtMPFV7sONvT8m+XQTQBoKZzdyGcYVc7Kd9y1u/
0Z1tnjFExAXjV8DKVkVLm2pzt2cu9LH4C8iuQjykZSfVT0SCyDZStorCTuwP4/XjCPSuap4d+sT3
Q29veLgS089rvLvN1jGc2/t+3bJQ6GuDpmZ4Z9+xYuKJ3hWtX9ySXZCotAJeFJTF5VZmTu9NpB/C
6yfAAgCZzuwN+i+vuiWBwHTYjD3DBMQs52O1owgouyAhxa8HjnfYCcIapdhyK8vxe5c21Uqx68Ca
y6Y6g/Nl9nim0LsWXGxsACYr9hdbrzH0E+A6sNrhMaxOZkt6P9U6sxoBn4qKEsMFDCNeME0ZRaC3
P3+ysK9JvI9pkTP9Q11i9tZynVQqNVPGn1TwYcB0jL8Cnq4wem2E/b2weWLcnRZwYmT8YTUCFJ1g
dL2Jex8ME3glS8w7uws4HlgIdIRR9JRlN46a1PjpzveiEtcKfiDK7shoNFaQNVTRLZnpX510XX3c
nq8Wv1nkGEijQ/De1DNMYGGh7SJDFw8oU2/GUw3tu/5nnKHLiRrXdGyqSxRvCUIuQnoJiKo5PgK2
Ofkrw3j0lXR75zOW7Rj38I8QCBJmTB26FnQHLuiJwUBLnCvqVrChvduH9L2hfqOiwez7vcCmHdnM
JTNLXANaKm9zMOJHCNpjfCDPBjNbXdP+3r7JMI28NRo0DV07o9Or2OsAevr8GQYnlbF7sXZ1555K
hsaiLdvRvzbesU5m92F0HUnfoCTPU3XJ4oq61TsmFfzgvLPKDj54z7a+eKrHCcwFdjYwbZiA16Sb
rt5VLSd8s9T6PcT9DJzCJoQgiXFtvph4Nr9q7hnSZBtKXVr2PxS8OY3tuRjZ5jRFOwUGlt5QGMHm
CU0J61naPD0ej1/gPXfLbO7kghiADTzQX5D8Wb23tz7auyq2Lh2fvWdswhhCftnsZmFfGAnAPowT
vWZZvMvl0nUSbcNj0JUm6qnmfOfNLenciszlLpl4IjJbf7TBj0GjZLd7hT/NF3f8dW5lW1NFrcDd
SFkGEnorlYw2A7ggSRIbeTgM6+2PBVWzyvRE4jhzuhM4H6tcOSul1wlSLmCnAN/Cc9rYkUPLMxlv
dnm5zBsPDSYRnFkYM1RX5iiZwldt8tLp1F7QP4HGkvSIvZJWx/CLKrBaH1q0GPQ2aOxWEfCqt+Ko
ratFBHHTZQatw1ThhcbVncP1whVCGWXdpMGU0AdVGyvLvl30LlgPtr3MfUHS0/LRFXXJtrsqz1Sy
8d6dG3xY+rLDHgTKM1CXl62rb9/9YfmM7nktbWBXM5R9xN5I/p5yHZcMgsiwkU5xQHnC9rb+nh2/
9Wjt4OU2c1xRl4zfUP/tna9admPosdTYOc5ImqGGNe9vS/fE7jKL/gzTSwwcVJ6vz8WeH/sGIwiC
OzFOHryMMJ48mHSjVikWxVWgyAFg3ojYLpNYX62QmSGp87H8qkyTC0s/qlmze1f5uPekbMwmlEZy
uD26vQC8sXdp05/XJVJft9D/2B7tGGmVlyyM52YcWILsqhGn2hqz4O/asu+OqtaxArHeBGGnwdll
7j7ftSpzGnT8VyUCQySgo73imBsJdkTfjVuVwdeGa8tl2kCQ+/WBSw27c+j2CQ47cVvqvnffGWvD
TWN7zqEtjO5nUgnpDi05YltQEX7g7dwoqIKsEnrebDvHZA8ijhsUlfAsr0l0Vmz0nGXxQpswjUpz
Mvtcbkbbl5Q9htO4B0wHyn+Sr3gmLkf/8nnzndOzDGQdA4USP+zrzj9R7a11DKCQSPwiWQx/A3y2
bGyKodvyxbatsOOto4k/puAlr/DKclnkNEEdGEAy1fd+WEi8jnEhgGHPOVdsn/nd/blqc4bTZ//y
OeeF5l7EynoTIWBLLIi+lLp357jW+uPAoW9mTo/H+WdgtozF9fd1jD8clWFUI5Vflfm+xHWMPzF1
4LmxNsXGiXr2o8GW7ILE3FJXEz7eYiX2Hqb/g6YH9vWSJegptC5zZnchfl6bLF48VHWPSKB31bzZ
XuF6ZOeOWokB7BPaIPFkfabzDftLjukFbtfyOVNjuLMxfR5nFyAWALsMvSzcKy4sbqQGfCH+jzI+
5cRXa9s7np0UAQk7vGLOHwSBPW2yeRX0/QARXpfX+vpU6YWJ7s6w3ZvmJ/saws8gfdnLzsdoYeBr
TXmCEJAD9gDPO2mXx9ZgPFnoid04/dHt3UckMITuFZnfc/CUGQtE9VRqKCfZLzH9Ssa7RHbQmfWZ
kYq8n2FmrZhOxWzhYFoc60+CHkPdhk0V1IzoyIM54LCz8Pya+3a9PmkCAIdubWuNJ3QLxtXAlGp6
HwH7kV6U7Dlc9N/ywRku4DOIUxk4Hc5icIUEz9QlOi6rlEonPA0p21zTU4ifFhirJLuwWvs8aQjh
+G0g1pfEM4UouXvGmm25oR7onZvmJ2fV0RAPCg3ybo6Hc4A/lnEm0uK61e+9fFQEhv0uIuib23q2
d9xg5v5IqNGgdrC6Vip03qCgga+QedA+sJ95Rc/UH9y5qfwt36T8Z8+N7c93zJi5tmPvMREoR25l
W5PwCyTmBsasSEwzsxpnCpArCfokuhzRPrDdMezdRH/YaQ/v6jtaX5PBR/rIJ7DNSxbGpjcfDDKH
Q6Mt5fmwJSK7MTqaj3uf4BP8P+J/ASVw7ffFYZkMAAAAAElFTkSuQmCC
"/> </g> </svg> </a> <a href=https://www.asterisk.org/blog/ target=_blank rel=noopener title=www.asterisk.org class=md-social__link> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 512 512"><!-- Font Awesome Free 7.0.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path fill=currentColor d="m61.7 169.4 101.5 278C92.2 413 43.3 340.2 43.3 256c0-30.9 6.6-60.1 18.4-86.6m337.9 75.9c0-26.3-9.4-44.5-17.5-58.7-10.8-17.5-20.9-32.4-20.9-49.9 0-19.6 14.8-37.8 35.7-37.8.9 0 1.8.1 2.8.2-37.9-34.7-88.3-55.9-143.7-55.9-74.3 0-139.7 38.1-177.8 95.9 5 .2 9.7.3 13.7.3 22.2 0 56.7-2.7 56.7-2.7 11.5-.7 12.8 16.2 1.4 17.5 0 0-11.5 1.3-24.3 2l77.5 230.4L249.8 247l-33.1-90.8c-11.5-.7-22.3-2-22.3-2-11.5-.7-10.1-18.2 1.3-17.5 0 0 35.1 2.7 56 2.7 22.2 0 56.7-2.7 56.7-2.7 11.5-.7 12.8 16.2 1.4 17.5 0 0-11.5 1.3-24.3 2l76.9 228.7 21.2-70.9c9-29.4 16-50.5 16-68.7m-139.9 29.3-63.8 185.5c19.1 5.6 39.2 8.7 60.1 8.7 24.8 0 48.5-4.3 70.6-12.1-.6-.9-1.1-1.9-1.5-2.9zm183-120.7c.9 6.8 1.4 14 1.4 21.9 0 21.6-4 45.8-16.2 76.2l-65 187.9C426.2 403 468.7 334.5 468.7 256c0-37-9.4-71.8-26-102.1M8 256a248 248 0 1 1 496 0 248 248 0 1 1-496 0m484.6 0a236.6 236.6 0 1 0-473.2 0 236.6 236.6 0 1 0 473.2 0"/></svg> </a> <a href=https://twitter.com/asteriskdev target=_blank rel=noopener title=twitter.com class=md-social__link> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 512 512"><!-- Font Awesome Free 7.0.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path fill=currentColor d="M459.4 151.7c.3 4.5.3 9.1.3 13.6 0 138.7-105.6 298.6-298.6 298.6-59.5 0-114.7-17.2-161.1-47.1 8.4 1 16.6 1.3 25.3 1.3 49.1 0 94.2-16.6 130.3-44.8-46.1-1-84.8-31.2-98.1-72.8 6.5 1 13 1.6 19.8 1.6 9.4 0 18.8-1.3 27.6-3.6-48.1-9.7-84.1-52-84.1-103v-1.3c14 7.8 30.2 12.7 47.4 13.3-28.3-18.8-46.8-51-46.8-87.4 0-19.5 5.2-37.4 14.3-53C87.4 130.8 165 172.4 252.1 176.9c-1.6-7.8-2.6-15.9-2.6-24C249.5 95.1 296.3 48 354.4 48c30.2 0 57.5 12.7 76.7 33.1 23.7-4.5 46.5-13.3 66.6-25.3-7.8 24.4-24.4 44.8-46.1 57.8 21.1-2.3 41.6-8.1 60.4-16.2-14.3 20.8-32.2 39.3-52.6 54.3"/></svg> </a> <a href=https://github.com/asterisk target=_blank rel=noopener title=github.com class=md-social__link> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 512 512"><!-- Font Awesome Free 7.0.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path fill=currentColor d="M173.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6m-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3m44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9M252.8 8C114.1 8 8 113.3 8 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C436.2 457.8 504 362.9 504 252 504 113.3 391.5 8 252.8 8M105.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1m-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7m32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1m-11.4-14.7c-1.6 1-1.6 3.6 0 5.9s4.3 3.3 5.6 2.3c1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2"/></svg> </a> <a href=https://community.asterisk.org target=_blank rel=noopener title=community.asterisk.org class=md-social__link> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 448 512"><!-- Font Awesome Free 7.0.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path fill=currentColor d="M225.9 32C103.3 32 0 130.5 0 252.1 0 256 .1 480 .1 480l225.8-.2c122.7 0 222.1-102.3 222.1-223.9S348.6 32 225.9 32M224 384c-19.4 0-37.9-4.3-54.4-12.1L88.5 392l22.9-75c-9.8-18.1-15.4-38.9-15.4-61 0-70.7 57.3-128 128-128s128 57.3 128 128-57.3 128-128 128"/></svg> </a> </div> </div> </div> </footer> </div> <div class=md-dialog data-md-component=dialog> <div class="md-dialog__inner md-typeset"></div> </div> <script id=__config type=application/json>{"base": "../../../..", "features": ["navigation.instant", "navigation.tracking", "navigation.prune", "navigation.indexes", "navigation.top", "search.suggest", "search.highlight", "search.share", "content.code.copy", "content.code.annotate", "toc.follow"], "search": "../../../../assets/javascripts/workers/search.973d3a69.min.js", "tags": null, "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": null}</script> <script src=../../../../assets/javascripts/bundle.92b07e13.min.js></script> </body> </html>